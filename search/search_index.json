{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Inicio","text":""},{"location":"index.html#programacion","title":"Programaci\u00f3n","text":"<p>En este repositorio vamos a agrupar los materiales realizadas en el m\u00f3dulo 0485 de Programaci\u00f3n del CFGS de Desarrollo de Aplicaciones Web/Multiplataforma (DAM), cuyo curriculum viene fijado por el Real Decreto 686/2010 actualizado por el Real Decreto 405/2023 de 29 de mayo de 2023.</p> <p>//TODO: Actualizar enlace al RD cuando est\u00e9 disponible</p>"},{"location":"index.html#resultados-de-aprendizaje","title":"Resultados de Aprendizaje","text":"<p>Los diferentes resultados de aprendizaje (RA) trabajados junto con su peso aproximado, tal cual se indica en la programaci\u00f3n did\u00e1ctica, son:</p> C\u00f3digo Descripci\u00f3n Peso (%) RA1 Reconoce la estructura de un programa inform\u00e1tico. RA2 Escribe y prueba programas sencillos. RA3 Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje. RA4 Desarrolla programas organizados en clases RA5 Realiza operaciones de entrada y salida de informaci\u00f3n. RA6 Escribe programas que manipulen informaci\u00f3n. RA7 Utiliza bases de datos orientadas a objetos. RA7 Gestiona informaci\u00f3n almacenada en bases de datos relacionales.."},{"location":"temas/00/index.html","title":"Pseuc\u00f3digo, algoritmos y pensamiento computacional","text":""},{"location":"temas/00/index.html#pseucodigo-algoritmos-y-pensamiento-computacional","title":"Pseuc\u00f3digo, algoritmos y pensamiento computacional","text":""},{"location":"temas/01/index.html","title":"01 - Introducci\u00f3n a la programaci\u00f3n","text":""},{"location":"temas/01/index.html#01-introduccion-a-la-programacion-software","title":"01 - Introducci\u00f3n a la Programaci\u00f3n Software","text":""},{"location":"temas/01/index.html#1-fundamentos-de-la-programacion","title":"1. Fundamentos de la Programaci\u00f3n","text":""},{"location":"temas/01/index.html#11-que-es-programar","title":"1.1. \u00bfQu\u00e9 es Programar?","text":"<p>Programar es el proceso de crear software. Esta disciplina abarca desde la concepci\u00f3n inicial de una idea hasta que el programa est\u00e1 implementado y funcionando en un ordenador, enfoc\u00e1ndose en los principios y metodolog\u00edas para el desarrollo y mantenimiento de sistemas de software. Algunos autores consideran que el t\u00e9rmino \"desarrollo de software\" es m\u00e1s apropiado que \"ingenier\u00eda de software\".</p> <p>Definici\u00f3n de Programa Software</p> <p>Un programa software es la parte intangible o l\u00f3gica de un sistema inform\u00e1tico, un conjunto de programas que act\u00faan sobre el hardware para ejecutar las tareas deseadas por el usuario. Los programas son m\u00e9todos para resolver problemas, procesando informaci\u00f3n para obtener un resultado a partir de datos de entrada. Para que un programa comience a funcionar, sus instrucciones deben ser traducidas a un lenguaje que la m\u00e1quina entienda.</p> Proceso de Entrada, Proceso y Salida en un Programa <p>El Proceso de Desarrollo de Software</p> <p>El desarrollo de software implica una serie de etapas obligatorias para construir software fiable y de calidad. Estas fases se dividen en tres pasos gen\u00e9ricos: definici\u00f3n (qu\u00e9 desarrollar), desarrollo, y mantenimiento.</p> <p>Las fases principales del desarrollo de una aplicaci\u00f3n inform\u00e1tica son:</p> <ul> <li> <p>Fase de Resoluci\u00f3n del Problema:</p> <ul> <li>An\u00e1lisis: Requiere que el problema sea definido y comprendido claramente. Se establecen los objetivos, el alcance y se realiza un estudio de viabilidad y costes. Se identifican los requisitos funcionales (qu\u00e9 funciones realizar\u00e1 la aplicaci\u00f3n) y no funcionales (caracter\u00edsticas de calidad del sistema). Tambi\u00e9n implica analizar la documentaci\u00f3n, investigar y recopilar informaci\u00f3n \u00fatil. La culminaci\u00f3n es el Documento de Especificaci\u00f3n de Requisitos del Software (ERS), que act\u00faa como contrato entre cliente y desarrollador.</li> <li>Dise\u00f1o: Se define \"c\u00f3mo\" hacer la soluci\u00f3n. Se convierte la especificaci\u00f3n del an\u00e1lisis en un dise\u00f1o detallado, indicando el comportamiento o la secuencia l\u00f3gica de instrucciones que resuelvan el problema. Se descompone la aplicaci\u00f3n en operaciones m\u00e1s sencillas y se asignan a m\u00f3dulos. Incluye el dise\u00f1o arquitect\u00f3nico, dise\u00f1o detallado, dise\u00f1o de datos y de interfaz de usuario. Es crucial realizar una prueba o traza del programa para asegurar la soluci\u00f3n antes de la implementaci\u00f3n.</li> </ul> <p></p> </li> <li> <p>Fase de Implementaci\u00f3n:</p> <ul> <li>Codificaci\u00f3n o Construcci\u00f3n: Consiste en transformar o traducir los resultados obtenidos a un determinado lenguaje de programaci\u00f3n. Se escribe el c\u00f3digo fuente siguiendo las reglas gramaticales y la sintaxis del lenguaje. El c\u00f3digo debe ser modular, correcto, legible, eficiente y portable.</li> <li>Pruebas de Ejecuci\u00f3n y Validaci\u00f3n: Se implanta la aplicaci\u00f3n en el sistema y se verifica su funcionamiento. Se utilizan diferentes datos de prueba para ver si el programa responde a los requerimientos. Incluye pruebas unitarias, de integraci\u00f3n, funcionales, estructurales y beta testing.</li> <li>Documentaci\u00f3n: Es vital para el desarrollo y mantenimiento. Se distinguen la documentaci\u00f3n interna (comentarios en el c\u00f3digo fuente) y documentaci\u00f3n externa (manuales t\u00e9cnicos, de usuario, de instalaci\u00f3n, diagramas).</li> </ul> <p></p> </li> <li> <p>Fase de Explotaci\u00f3n y Mantenimiento:</p> <ul> <li>Explotaci\u00f3n (Despliegue): Los usuarios finales utilizan la aplicaci\u00f3n. Implica instalaci\u00f3n, puesta a punto y funcionamiento en el equipo del cliente.</li> <li>Mantenimiento: Peri\u00f3dicamente, se realizan evaluaciones y modificaciones para adaptar el programa a nuevas necesidades, corregir errores o actualizarlo.</li> <li>Retirada del Software: Ocurre cuando el software llega al final de su vida \u00fatil y no es rentable mantenerlo.</li> </ul> </li> </ul> <p>A lo largo de todo el proceso de desarrollo de software, se debe aplicar siempre un modelo de ciclo de vida. Estos modelos son la serie de pasos a seguir para desarrollar un programa.</p> Ciclo de Vida del Software"},{"location":"temas/01/index.html#12-algoritmos-la-receta-para-resolver-problemas","title":"1.2. Algoritmos: La Receta para Resolver Problemas \ud83c\udf73","text":"<p>Imagina que quieres hacer una tortilla de patatas. \u00bfQu\u00e9 haces? No empiezas a echar ingredientes al azar, \u00bfverdad? Sigues una serie de pasos ordenados: pelar y cortar las patatas, batir los huevos, fre\u00edr las patatas, mezclarlo todo y cuajar la tortilla.</p> <p>Pues bien, un algoritmo es exactamente eso: una secuencia de pasos finitos, claros y ordenados que nos llevan a la soluci\u00f3n de un problema o a la consecuci\u00f3n de una tarea.</p> <p>Los algoritmos est\u00e1n por todas partes en nuestra vida, no solo en la inform\u00e1tica.</p> <p>Concepto de Algoritmo y sus Caracter\u00edsticas</p> <p>Un algoritmo es una serie de pasos claros y ordenados que te permiten resolver un problema espec\u00edfico. No es un programa de computadora en s\u00ed mismo, sino la idea detr\u00e1s del programa. Piensa en \u00e9l como una receta de cocina: sin importar si la preparas en una estufa de gas, el\u00e9ctrica o de le\u00f1a, el resultado es el mismo porque la receta (el algoritmo) es independiente de la herramienta. Un algoritmo te dice qu\u00e9 hacer y en qu\u00e9 orden, sin importar la m\u00e1quina o el lenguaje de programaci\u00f3n.</p> <p>Ejemplos de Algoritmos de la Vida Cotidiana</p> <ul> <li> <p>Receta de cocina: Como hemos visto, una receta es un algoritmo perfecto. Te dice qu\u00e9 ingredientes necesitas (datos de entrada) y qu\u00e9 pasos seguir (proceso) para obtener un plato concreto (resultado).</p> </li> <li> <p>Montar un mueble de IKEA: Las instrucciones son un algoritmo. Si te saltas un paso o lo haces en el orden incorrecto, lo m\u00e1s probable es que el mueble no quede bien.</p> </li> <li> <p>Seguir una ruta en Google Maps: Le dices a d\u00f3nde quieres ir (problema), y la aplicaci\u00f3n calcula una serie de instrucciones paso a paso (\"gira a la derecha en 200 metros\", \"contin\u00faa recto\"...) para que llegues a tu destino (soluci\u00f3n).</p> </li> <li> <p>Sacar dinero de un cajero:</p> <ol> <li>Introducir tarjeta.</li> <li>Teclear el PIN.</li> <li>Seleccionar \"Sacar dinero\".</li> <li>Elegir la cantidad.</li> <li>Recoger el dinero.</li> <li>Recoger la tarjeta.</li> <li>Finalizar.</li> </ol> </li> </ul> <p>En programaci\u00f3n, antes de escribir una sola l\u00ednea de c\u00f3digo, primero pensamos en el algoritmo que resolver\u00e1 nuestro problema</p>"},{"location":"temas/01/index.html#121-caracteristicas-esenciales","title":"1.2.1. Caracter\u00edsticas Esenciales","text":"<p>Para que un algoritmo sea considerado de calidad, debe cumplir con las siguientes caracter\u00edsticas:</p> <ul> <li>Finito: Siempre debe terminar en un n\u00famero limitado de pasos. No puede ser un proceso infinito.</li> <li>Preciso: Cada paso debe ser claro y no dar lugar a ambig\u00fcedades.</li> <li>Definido: Si usas los mismos datos de entrada, el algoritmo siempre debe producir el mismo resultado.</li> <li>Eficiente: Debe utilizar la menor cantidad de recursos (tiempo y memoria) posible.</li> <li>General: Debe servir para resolver una clase de problemas, no solo un caso particular.</li> <li>Correcto: Debe resolver el problema para el cual fue dise\u00f1ado.</li> </ul> <p>Adem\u00e1s de estas caracter\u00edsticas fundamentales, un buen algoritmo debe ser comprensible, modificable y reutilizable, lo que facilita su uso y mantenimiento a lo largo del tiempo. Para lograrlo, es crucial que est\u00e9 bien estructurado y documentado con comentarios. Finalmente, todo algoritmo debe ser probado para asegurar que funciona correctamente en todos los casos posibles.</p> Diagrama de flujo de un algoritmo <p>Reglas para el Dise\u00f1o de Algoritmos (Abstracci\u00f3n, Modularidad)</p> <p>Para dise\u00f1ar soluciones correctas y eficientes, se deben considerar los siguientes conceptos:</p> <ol> <li>Abstracci\u00f3n: Realizar un an\u00e1lisis del problema para descomponerlo en problemas m\u00e1s peque\u00f1os y de menor complejidad, describiendo cada uno de manera precisa.</li> <li>Divide y vencer\u00e1s: Una filosof\u00eda general para resolver problemas, central en el enfoque de abstracci\u00f3n y modularidad.</li> <li>Encapsulaci\u00f3n: Ocultar la informaci\u00f3n para poder implementarla de diferentes maneras sin que esto influya en el resto de elementos.</li> <li>Modularidad: Estructurar cada parte en m\u00f3dulos independientes, donde cada uno tendr\u00e1 su funci\u00f3n correspondiente. El dise\u00f1o modular (top-down design) descompone un problema en subproblemas m\u00e1s sencillos.</li> </ol> <p>Para representar los algoritmos gr\u00e1ficamente, se pueden usar herramientas como diagramas de flujo (que usan s\u00edmbolos gr\u00e1ficos y se utilizan en fases de an\u00e1lisis) y pseudoc\u00f3digo (basado en palabras clave en lenguaje natural y es la t\u00e9cnica m\u00e1s utilizada).</p>"},{"location":"temas/01/index.html#122-diferencia-entre-algoritmo-y-programa","title":"1.2.2. Diferencia entre Algoritmo y Programa","text":"<p>La diferencia fundamental entre algoritmo y programa radica en que el algoritmo es una descripci\u00f3n de los pasos para resolver un problema de forma gen\u00e9rica e independiente de la m\u00e1quina y del lenguaje de programaci\u00f3n. En cambio, el programa consiste en esos mismos pasos, pero escritos en un lenguaje de programaci\u00f3n espec\u00edfico para que puedan ser ejecutados en un ordenador y obtener la soluci\u00f3n. Los lenguajes de programaci\u00f3n son solo un medio para expresar el algoritmo, y el ordenador es el procesador para ejecutarlo.</p> <p>Tabla 1: Comparaci\u00f3n entre Algoritmo y Programa</p> Caracter\u00edstica Algoritmo Programa Nivel de Abstracci\u00f3n Gen\u00e9rico, independiente de la m\u00e1quina y el lenguaje. Espec\u00edfico, escrito en un lenguaje de programaci\u00f3n. Formato Secuencia de pasos l\u00f3gicos, pseudoc\u00f3digo, diagramas de flujo. C\u00f3digo fuente, instrucciones en un lenguaje concreto. Ejecuci\u00f3n No ejecutable directamente por una m\u00e1quina. Ejecutable por un ordenador despu\u00e9s de ser traducido. Objetivo Describir la soluci\u00f3n a un problema. Implementar la soluci\u00f3n para que una m\u00e1quina la ejecute."},{"location":"temas/01/index.html#2-lenguajes-de-programacion","title":"2. Lenguajes de Programaci\u00f3n","text":""},{"location":"temas/01/index.html#21-conceptos-fundamentales-del-lenguaje","title":"2.1. Conceptos Fundamentales del Lenguaje","text":"<p>Un lenguaje de programaci\u00f3n es un idioma artificial, un conjunto de reglas sint\u00e1cticas y sem\u00e1nticas, s\u00edmbolos y palabras especiales establecidas para la construcci\u00f3n de programas. Estos elementos permiten al programador escribir secuencias de comandos para que una m\u00e1quina realice un comportamiento deseado.</p> <p>Los elementos que componen un lenguaje de programaci\u00f3n son:</p> <ul> <li>L\u00e9xico (Alfabeto): Es el conjunto finito de s\u00edmbolos permitidos y palabras especiales, el vocabulario del lenguaje: letras, d\u00edgitos, operadores, signos de puntuaci\u00f3n y palabras reservadas. Estos s\u00edmbolos se combinan para formar los elementos b\u00e1sicos del lenguaje, como identificadores, literales y operadores. Ejemplos de l\u00e9xico son: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>;</code>, <code>{}</code>, <code>()</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>int</code>, <code>decimal</code>, <code>string</code>, <code>bool</code>, etc.</li> <li>Sintaxis: Son las normas de construcci\u00f3n que rigen la estructura de las declaraciones y expresiones v\u00e1lidas en el lenguaje. Se refiere a las posibles combinaciones de los s\u00edmbolos y palabras especiales. Define c\u00f3mo se deben organizar los elementos l\u00e9xicos para formar sentencias correctas. Por ejemplo, en muchos lenguajes, una sentencia de asignaci\u00f3n debe seguir la estructura <code>identificador = expresi\u00f3n;</code>. La sintaxis es crucial para que el compilador o int\u00e9rprete pueda entender y procesar el c\u00f3digo correctamente. Ejemplo de una sentencia sint\u00e1cticamente correcta: <code>int numero = 10;</code>.</li> <li>Sem\u00e1ntica: Es el significado de las construcciones y define las acciones que se llevar\u00e1n a cabo con las combinaciones de los s\u00edmbolos. Es importante tener en cuenta que pueden existir sentencias sint\u00e1cticamente correctas, pero sem\u00e1nticamente incorrectas. Por ejemplo, la sentencia <code>int numero = \"texto\";</code> es sint\u00e1cticamente correcta, pero sem\u00e1nticamente incorrecta porque intenta asignar un valor de tipo cadena a una variable de tipo entero. La sem\u00e1ntica asegura que las operaciones y combinaciones de elementos tengan sentido dentro del contexto del lenguaje y el problema que se est\u00e1 resolviendo.</li> </ul>"},{"location":"temas/01/index.html#22-paradigmas-de-programacion","title":"2.2. Paradigmas de Programaci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n es un modelo fundamental o una filosof\u00eda para el dise\u00f1o y la implementaci\u00f3n de programas. Este modelo determina c\u00f3mo ser\u00e1 el proceso de dise\u00f1o y la estructura final del c\u00f3digo. Son como las \"reglas del juego\" que gu\u00edan c\u00f3mo se aborda la soluci\u00f3n de un problema. El objetivo es reducir la dificultad para el mantenimiento, mejorar el rendimiento del programador y, en general, mejorar la productividad y calidad de los programas.</p> <p>Tipos de Paradigmas</p> <p>Existen diversos paradigmas, y muchos lenguajes modernos son multiparadigma, combinando caracter\u00edsticas de varios para ofrecer flexibilidad (ej. Python, JavaScript, Java, Kotlin, C#).</p> <ul> <li>Programaci\u00f3n Imperativa/Estructurada: Se basa en una serie de comandos que la computadora ejecuta en orden para cambiar el estado del programa. Utiliza estructuras como sentencias secuenciales, selectivas (condicionales) y repetitivas (bucles). Ejemplos incluyen C y Pascal.</li> <li>Programaci\u00f3n Procedimental: Un subtipo del paradigma imperativo. Los programas se organizan en procedimientos (o funciones) que manipulan el estado global del programa, buscando la modularidad. Ejemplos incluyen C, Pascal y BASIC.</li> <li>Programaci\u00f3n Orientada a Objetos (POO): Es el paradigma m\u00e1s utilizado. Los programas se construyen como una colecci\u00f3n de objetos que interact\u00faan entre s\u00ed. Un objeto es una instancia de una clase que contiene datos (atributos) y m\u00e9todos para operar sobre ellos. La POO promueve la reutilizaci\u00f3n de c\u00f3digo, depuraci\u00f3n m\u00e1s sencilla y mejor mantenimiento, bas\u00e1ndose en pilares como el polimorfismo, la herencia y la encapsulaci\u00f3n. Ejemplos: C++, Python, Kotlin, C#. Java es un lenguaje totalmente orientado a objetos.</li> <li>Programaci\u00f3n Declarativa: Los programas describen el resultado deseado, no el proceso paso a paso para lograrlo. Suelen ser lenguajes interpretados.<ul> <li>L\u00f3gica: Utiliza reglas y afirmaciones de l\u00f3gica formal para que la computadora deduzca la respuesta, muy usada en inteligencia artificial. Ejemplo: Prolog.</li> <li>Funcional: Se enfoca en el uso de funciones matem\u00e1ticas que no cambian el estado ni los datos externos, promoviendo c\u00f3digo modular y estructurado. Ejemplos: Lisp, Haskell, Scala.</li> </ul> </li> <li>Programaci\u00f3n de Eventos: El flujo del programa es impulsado por eventos (clics, movimientos del rat\u00f3n, etc.). Com\u00fan en interfaces gr\u00e1ficas de usuario (GUI) y servidores.</li> <li>Programaci\u00f3n Reactiva: Un subtipo de la programaci\u00f3n de eventos que gestiona flujos de datos asincr\u00f3nicos y la propagaci\u00f3n de cambios, ideal para aplicaciones en tiempo real.</li> <li>Programaci\u00f3n Multiparadigma: Lenguajes que admiten y combinan m\u00faltiples paradigmas, permitiendo elegir el mejor enfoque para cada parte del problema. Ejemplos: C++, JavaScript, Python, Kotlin, C#.</li> </ul>"},{"location":"temas/01/index.html#23-clasificacion-de-lenguajes-de-programacion","title":"2.3. Clasificaci\u00f3n de Lenguajes de Programaci\u00f3n","text":"<p>Los lenguajes de programaci\u00f3n pueden ser clasificados en funci\u00f3n de lo cerca que est\u00e9n del lenguaje humano o del lenguaje de los computadores.</p> <p>Seg\u00fan su cercan\u00eda al lenguaje humano (Nivel de Abstracci\u00f3n)</p> Lenguajes de Bajo NivelLenguajes de Bajo MedioLenguajes de Alto Nivel <p>Totalmente dependientes de la m\u00e1quina; un programa no puede migrarse a otras m\u00e1quinas. Aprovechan al m\u00e1ximo las caracter\u00edsticas del hardware.</p> <ul> <li> <p>Lenguaje M\u00e1quina: Instrucciones en combinaciones de unos y ceros (c\u00f3digo binario). Es el \u00fanico lenguaje que el ordenador entiende directamente (no necesita traducci\u00f3n). Fue el primer lenguaje, \u00fanico para cada procesador (no portable), r\u00e1pido pero dif\u00edcil de manejar y depurar.</p> Operaci\u00f3n Lenguaje m\u00e1quina Decimal SUMAR 00101101 45 RESTAR 00010011 19 MOVER 00111010 58 </li> <li> <p>Lenguaje Ensamblador: Sustituy\u00f3 al lenguaje m\u00e1quina, utilizando mnemot\u00e9cnicos (c\u00f3digos de operaci\u00f3n) en lugar de binarios. Necesita un programa ensamblador que lo traduzca a lenguaje m\u00e1quina para ejecutarse. Aunque m\u00e1s legible, sigue siendo de bajo nivel, dependiente del hardware y dif\u00edcil de usar, interpretar y modificar.</p> Operaci\u00f3n Mnemot\u00e9cnico MULTIPLICAR MUL DIVIDIR DIV MOVER MOV </li> </ul> <p>Lenguajes de Medio Nivel: T\u00e9rmino no universalmente aceptado, se refiere a lenguajes como C que pueden acceder a registros del sistema y direcciones de memoria (caracter\u00edsticas de bajo nivel) mientras realizan operaciones de alto nivel.   </p> <p>Lenguajes de Alto Nivel: Cercanos al lenguaje natural (ingl\u00e9s), independientes de la arquitectura del ordenador. Permiten al programador abstraerse del funcionamiento interno de la m\u00e1quina. Utilizan sentencias y \u00f3rdenes derivadas del idioma ingl\u00e9s. Necesitan un traductor para ser entendidos por la m\u00e1quina. Incorporan librer\u00edas, funciones predeterminadas y suelen ofrecer frameworks. La mayor\u00eda de los lenguajes actuales se engloban aqu\u00ed. Ejemplos: C++, Java, Python, JavaScript, PHP.</p> <p></p>"},{"location":"temas/01/index.html#232-segun-su-mecanismo-de-traduccion-compilados-interpretados-mixtos","title":"2.3.2. Seg\u00fan su mecanismo de traducci\u00f3n (Compilados, Interpretados, Mixtos)","text":"<p>Los programas se traducen a c\u00f3digo binario ejecutable mediante compilaci\u00f3n o interpretaci\u00f3n.</p> <ul> <li> <p>Lenguajes Compilados: Necesitan un compilador que traduce el c\u00f3digo fuente completo a c\u00f3digo objeto (o c\u00f3digo m\u00e1quina) en un solo paso, antes de la ejecuci\u00f3n. La ejecuci\u00f3n es eficiente. Requieren un enlazador para unir el c\u00f3digo objeto con librer\u00edas. El c\u00f3digo es m\u00e1s seguro, ya que el c\u00f3digo fuente no es directamente accesible. Ejemplos: C y C++.</p> <p>Un compilador realiza varias fases: 1.  An\u00e1lisis L\u00e9xico: Agrupa el c\u00f3digo fuente en tokens. 2.  An\u00e1lisis Sint\u00e1ctico: Comprueba la estructura gramatical y genera un \u00e1rbol sint\u00e1ctico. 3.  An\u00e1lisis Sem\u00e1ntico: Verifica la l\u00f3gica y compatibilidad de tipos. 4.  Generaci\u00f3n de C\u00f3digo Intermedio: Un c\u00f3digo de bajo nivel independiente de la arquitectura. 5.  Optimizaci\u00f3n de C\u00f3digo: Mejora el c\u00f3digo para mayor eficiencia. 6.  Generaci\u00f3n de C\u00f3digo Objeto: Convierte el c\u00f3digo a lenguaje m\u00e1quina espec\u00edfico. 7.  Enlazador (Linker): Une el c\u00f3digo objeto con librer\u00edas.</p> </li> <li> <p>Lenguajes Interpretados: No generan c\u00f3digo objeto. Un int\u00e9rprete lee y ejecuta el c\u00f3digo fuente l\u00ednea a l\u00ednea, o instrucci\u00f3n por instrucci\u00f3n, en el momento. Son menos eficientes en ejecuci\u00f3n que los compilados, ya que se traducen en tiempo de ejecuci\u00f3n. Requieren que el int\u00e9rprete est\u00e9 cargado en memoria. El c\u00f3digo fuente es legible, lo que puede comprometer la seguridad. Ejemplos: Perl, PHP, Python, JavaScript.</p> </li> <li> <p>Lenguajes Mixtos o Virtuales (Intermediarios): Combinan caracter\u00edsticas de ambos. El c\u00f3digo fuente se compila a un c\u00f3digo binario intermedio (no ejecutable) llamado bytecode. Este bytecode es luego interpretado por una m\u00e1quina virtual para ejecutarlo en cualquier plataforma compatible. Son m\u00e1s portables, buscando \"compilar una vez y ejecutar en cualquier sistema\". Java y C# son ejemplos clave de lenguajes mixtos.</p> </li> </ul> Diferencias entre lenguajes compilados, interpretados y mixtos"},{"location":"temas/01/index.html#233-segun-su-sistema-de-tipos-rigidez-momento-de-verificacion-declaracion-sin-tipado","title":"2.3.3. Seg\u00fan su sistema de tipos (Rigidez, Momento de Verificaci\u00f3n, Declaraci\u00f3n, Sin Tipado)","text":"<p>Un tipo de dato es una clasificaci\u00f3n que define el conjunto de valores que una variable puede tomar y las operaciones v\u00e1lidas que se pueden realizar sobre esos valores. Esta clasificaci\u00f3n es fundamental porque determina la cantidad de memoria que el sistema operativo debe reservar para la variable.</p> <p>El sistema de tipos de un lenguaje de programaci\u00f3n es un conjunto de reglas que definen c\u00f3mo se manejan y verifican estos tipos de datos.</p> <p>Sistemas de Tipado</p> <ul> <li>Rigidez (Tipado Fuerte vs. Tipado D\u00e9bil):<ul> <li>Tipado Fuerte: Requiere que los tipos de datos sean compatibles para realizar operaciones, evitando conversiones autom\u00e1ticas o \"impl\u00edcitas\" entre tipos no relacionados. Esto previene errores inesperados y hace el c\u00f3digo m\u00e1s robusto. Ejemplos: Python, Java, C#, Ruby.</li> <li>Tipado D\u00e9bil: Permite conversiones de tipo autom\u00e1ticas, lo que puede llevar a errores dif\u00edciles de detectar. Ejemplos: JavaScript, PHP, VBScript.</li> </ul> </li> <li>Momento de Verificaci\u00f3n (Tipado Est\u00e1tico vs. Tipado Din\u00e1mico):<ul> <li>Tipado Est\u00e1tico: La verificaci\u00f3n de tipos se realiza en tiempo de compilaci\u00f3n. El tipo de cada variable debe ser conocido y, a menudo, declarado expl\u00edcitamente antes de ejecutar el programa. Si hay un error de tipo, el programa no compilar\u00e1. Garantiza mayor seguridad y rendimiento. Ejemplos: C++, Java, C#, Swift.</li> <li>Tipado Din\u00e1mico: La verificaci\u00f3n de tipos se realiza en tiempo de ejecuci\u00f3n. No es necesario declarar el tipo de una variable expl\u00edcitamente; el int\u00e9rprete lo determina autom\u00e1ticamente. Una misma variable puede cambiar de tipo durante la ejecuci\u00f3n. Ofrece flexibilidad, pero los errores de tipo solo se descubren en ejecuci\u00f3n. Ejemplos: Python, JavaScript, Ruby, PHP.</li> </ul> </li> <li>Declaraci\u00f3n (Tipado Expl\u00edcito vs. Impl\u00edcito - Inferencia):<ul> <li>Tipado Expl\u00edcito: El programador debe declarar manualmente el tipo de cada variable. Ejemplo en C++: <code>int numero = 10;</code>.</li> <li>Tipado Impl\u00edcito (Inferencia de Tipos): El compilador o int\u00e9rprete deduce el tipo de la variable a partir del valor asignado, sin que el programador tenga que declararlo. Esto hace el c\u00f3digo m\u00e1s conciso y r\u00e1pido de escribir. Ejemplo en Python: <code>numero = 10;</code>.</li> </ul> </li> <li>Lenguajes sin Tipado (Tipado Nulo): En lenguajes de muy bajo nivel, como el ensamblador, no existe un sistema de tipos formal. Las variables se manejan como secuencias de bits, y es responsabilidad del programador interpretar los datos.</li> </ul> <p> </p> <p>Tabla: Clasificaci\u00f3n de Lenguajes seg\u00fan su Sistema de Tipado</p> Sistema de Tipado Descripci\u00f3n Ejemplos de Lenguajes Est\u00e1tico y Fuerte Tipos verificados en compilaci\u00f3n; no hay conversiones impl\u00edcitas. C++, Java, C# Din\u00e1mico y Fuerte Tipos verificados en ejecuci\u00f3n; no hay conversiones impl\u00edcitas. Python, Ruby Est\u00e1tico y D\u00e9bil Tipos verificados en compilaci\u00f3n; s\u00ed hay conversiones impl\u00edcitas. C, VBScript (algunos) Din\u00e1mico y D\u00e9bil Tipos verificados en ejecuci\u00f3n; s\u00ed hay conversiones impl\u00edcitas. JavaScript, PHP"},{"location":"temas/01/index.html#234-segun-generaciones","title":"2.3.4. Seg\u00fan Generaciones","text":"<p>La evoluci\u00f3n de los lenguajes de programaci\u00f3n se puede dividir en 5 etapas o generaciones:</p> <ul> <li>Primera Generaci\u00f3n: Lenguaje m\u00e1quina.</li> <li>Segunda Generaci\u00f3n: Creaci\u00f3n de los primeros lenguajes ensambladores.</li> <li>Tercera Generaci\u00f3n: Creaci\u00f3n de los primeros lenguajes de alto nivel (C, Pascal, Cobol).</li> <li>Cuarta Generaci\u00f3n: Lenguajes capaces de generar c\u00f3digo por s\u00ed solos (RAD), con los cuales se pueden realizar aplicaciones sin ser experto. Incluyen lenguajes orientados a objetos, permitiendo la reutilizaci\u00f3n de c\u00f3digo. Suelen tener acceso a bases de datos, capacidades gr\u00e1ficas y generaci\u00f3n de c\u00f3digo autom\u00e1tica. Ej. Visual Studio, IntelliJ.</li> <li>Quinta Generaci\u00f3n: Lenguajes orientados a la inteligencia artificial (LISP).</li> </ul> <p></p>"},{"location":"temas/01/index.html#3-elementos-fundamentales-en-la-programacion","title":"3. Elementos Fundamentales en la Programaci\u00f3n","text":""},{"location":"temas/01/index.html#31-estructura-y-bloques-fundamentales-de-un-programa","title":"3.1. Estructura y Bloques Fundamentales de un Programa","text":"<p>Para escribir programas, es importante seguir una estructura definida que facilite su comprensi\u00f3n y mantenimiento. A lo largo de este tema usaremos el pseudoc\u00f3digo especial o lenguaje de DAW. Este lenguaje de nuestro curso es estructurado, similar a C# y Java, pero con una sintaxis simplificada y adaptada para el aprendizaje.</p> <p></p> <p>Estructura General de un Programa (Funci\u00f3n Principal <code>Main()</code>)</p> <p>Un programa se organiza alrededor de una bloque principal que sirve como punto de entrada para su ejecuci\u00f3n. Este bloque se denomina <code>Main()</code> en el lenguaje DAW. Todo programa debe tener este bloque principal, que contiene las instrucciones que se ejecutan al iniciar el programa. Es decir, la l\u00f3gica del programa y/o algoritmo se escribe dentro de este bloque.</p> <pre><code>// Mi primer programa en pseudoc\u00f3digo DAW\nMain() {\n  // Aqu\u00ed se escribir\u00e1 el c\u00f3digo principal del programa\n  writeLine(\"\u00a1Hola, mundo de la programaci\u00f3n!\");\n}\n</code></pre> <p>Reglas de Sintaxis B\u00e1sicas (Bloques de C\u00f3digo <code>{ }</code>, Punto y Coma <code>;</code>)</p> <ul> <li>Bloques de c\u00f3digo <code>{ }</code>: Son conjuntos de instrucciones que se agrupan, marcadas por la apertura y cierre de llaves. El c\u00f3digo dentro de ellas es considerado interno al bloque.</li> <li>Punto y coma <code>;</code>: Cada instrucci\u00f3n o sentencia (que no sea un bloque de c\u00f3digo o una declaraci\u00f3n de bloque) debe finalizar con un punto y coma. Su omisi\u00f3n resulta en errores sint\u00e1cticos.</li> <li>Comentarios <code>//</code> y <code>/* */</code>: Se utilizan para agregar notas explicativas al c\u00f3digo. Los comentarios de una l\u00ednea comienzan con <code>//</code>, mientras que los de varias l\u00edneas se encierran entre <code>/*</code> y <code>*/</code>.</li> <li>Espacios en blanco: Se pueden usar espacios en blanco y tabulaciones para mejorar la legibilidad del c\u00f3digo. No afectan la ejecuci\u00f3n, pero es importante ser consistente. Es obligatorio usar tabulaciones o espacios para la indentaci\u00f3n del c\u00f3digo dentro de bloques. Se recomienda usar 4 espacios por nivel de indentaci\u00f3n.</li> <li>Saltos de l\u00ednea: Se pueden usar para separar instrucciones y mejorar la legibilidad. Cada instrucci\u00f3n debe estar en una l\u00ednea separada.</li> <li>Identaci\u00f3n: Es la pr\u00e1ctica de alinear el c\u00f3digo dentro de bloques para reflejar su estructura jer\u00e1rquica. Mejora la legibilidad y facilita la comprensi\u00f3n del flujo del programa.</li> </ul> <pre><code>// Ejemplo de indentaci\u00f3n correcta\nMain() {\n  writeLine(\"Inicio del programa\");\n  if (true) {\n      writeLine(\"Condici\u00f3n verdadera\");\n  } else {\n      writeLine(\"Condici\u00f3n falsa\");\n  }\n  writeLine(\"Fin del programa\");\n}\n</code></pre> <p>Sensibilidad a May\u00fasculas y Min\u00fasculas</p> <p>El pseudoc\u00f3digo, al igual que muchos lenguajes de programaci\u00f3n reales, es sensible a may\u00fasculas y min\u00fasculas. Esto significa que <code>variable</code> y <code>Variable</code> ser\u00edan consideradas dos elementos distintos. Es una buena pr\u00e1ctica mantener una convenci\u00f3n de nomenclatura consistente.</p> <pre><code>Main() {\n  int numero = 10; // Variable en min\u00fasculas\n  int Numero = 20; // Variable en may\u00fascula, diferente de 'numero'\n  writeLine(numero); // Imprime 10\n  writeLine(Numero); // Imprime 20\n}\n</code></pre>"},{"location":"temas/01/index.html#32-tipos-de-datos-basicos","title":"3.2. Tipos de Datos B\u00e1sicos","text":""},{"location":"temas/01/index.html#321-concepto-de-tipo-de-dato-valores-validos-operaciones-y-espacio-en-memoria","title":"3.2.1. Concepto de Tipo de Dato: Valores v\u00e1lidos, operaciones y espacio en memoria**","text":"<p>Un tipo de dato es una clasificaci\u00f3n fundamental que especifica: *   El conjunto de valores v\u00e1lidos que una variable puede tomar. *   Las operaciones permitidas sobre esos valores. *   La cantidad de memoria que el sistema operativo debe reservar para la variable.</p> <p>En un lenguaje fuertemente tipado, como el que se simula, a todo dato se le asigna un tipo que se conoce antes de la ejecuci\u00f3n del programa, y el lenguaje controla exhaustivamente la compatibilidad de tipos. esto ayuda a prevenir errores y garantiza que las operaciones se realicen de manera segura y predecible. En lenguajes de tipado din\u00e1mico, los tipos se determinan en tiempo de ejecuci\u00f3n, lo que ofrece mayor flexibilidad pero puede introducir errores si no se manejan adecuadamente.</p>"},{"location":"temas/01/index.html#322-tipos-de-datos-comunes-y-su-uso-de-memoria","title":"3.2.2. Tipos de Datos Comunes (y su uso de memoria)","text":"<p>Los tipos de datos que m\u00e1s utilizaremos en el pseudoc\u00f3digo son <code>int</code>, <code>decimal</code>, <code>string</code> y <code>bool</code>.</p> <ul> <li>Enteros (<code>int</code>):<ul> <li>Almacena n\u00fameros enteros (sin decimales), positivos y negativos.</li> <li>Valores: Un rango amplio, por ejemplo, de aproximadamente -2.147.483.648 a 2.147.483.647. Se utilizan para contar o en operaciones matem\u00e1ticas sin fracciones.</li> <li>Uso de memoria: Generalmente ocupan 32 bits (4 bytes) en la mayor\u00eda de los sistemas.</li> </ul> </li> <li>Reales (<code>decimal</code>):<ul> <li>Almacena n\u00fameros con decimales. Se usan para operaciones financieras o cient\u00edficas.</li> <li>Valores: Con alta precisi\u00f3n (hasta 15 o 16 d\u00edgitos decimales). Los n\u00fameros reales se representan de forma aproximada en un ordenador debido a su capacidad finita de almacenamiento.</li> <li>Uso de memoria: Generalmente ocupan 64 bits (8 bytes).</li> </ul> </li> <li>Cadenas (<code>string</code>):<ul> <li>Almacena una secuencia de caracteres. Se utiliza para texto, nombres, frases.</li> <li>Valores: Cualquier texto entre comillas dobles.</li> <li>Uso de memoria: Las cadenas son tipos de referencia, lo que significa que su tama\u00f1o var\u00eda seg\u00fan la longitud de la cadena, ya que almacenan una direcci\u00f3n de memoria a la cadena real.</li> </ul> </li> <li>Booleanos (<code>bool</code>):<ul> <li>Almacena un valor l\u00f3gico. Se utiliza para condiciones de verdadero o falso.</li> <li>Valores: Solo <code>true</code> o <code>false</code>.</li> <li>Uso de memoria: Generalmente ocupan 1 bit, pero suelen almacenarse en un byte para eficiencia.</li> </ul> </li> </ul> <p>Tabla 5: Tipos de Datos B\u00e1sicos, Valores y Uso de Memoria</p> Tipo de Dato Descripci\u00f3n Rango/Valores Comunes Uso de Memoria (T\u00edpico) <code>int</code> N\u00fameros enteros \u00b1 2 mil millones (aprox. 32 bits) 4 bytes (32 bits) <code>decimal</code> N\u00fameros con decimales \u00b1 1.7E+308 (aprox. 64 bits) 8 bytes (64 bits) <code>string</code> Secuencia de caracteres Texto entre comillas dobles Variable (tipo referencia) <code>bool</code> Valores l\u00f3gicos <code>true</code>, <code>false</code> 1 byte (para 1 bit)"},{"location":"temas/01/index.html#323-tipos-de-datos-enumerados-enum","title":"3.2.3. Tipos de Datos Enumerados (<code>enum</code>)","text":"<p>Los tipos enumerados (<code>enum</code>) permiten definir un nuevo tipo cuyos valores posibles son un conjunto de nombres simb\u00f3licos predefinidos. Son \u00fatiles para representar un conjunto fijo de constantes con significado. Para declararlos se usa la palabra reservada <code>enum</code>, seguida del nombre del <code>enum</code> y la lista de valores que puede tomar entre llaves <code>{}</code>. Los valores se consideran constantes, van separados por comas y deben ser \u00fanicos.</p> <p></p><pre><code>enum Dias { LUNES, MARTES, MIERCOLES, JUEVES, VIERNES, SABADO, DOMINGO };\n\nMain() {\n  Dias diaActual = Dias.MARTES;\n  Dias diaSiguiente = Dias.MIERCOLES;\n\n  writeLine(\"Hoy es: \" + diaActual);\n  writeLine(\"Ma\u00f1ana es: \" + diaSiguiente);\n}\n</code></pre> El <code>enum</code> permite definir un nuevo tipo cuyos valores posibles son los que nosotros definamos.<p></p>"},{"location":"temas/01/index.html#324-control-de-nulos-null-en-tipos-de-datos-operador-para-tipos-de-valor","title":"3.2.4. Control de Nulos (<code>null</code>) en Tipos de Datos (operador <code>?</code> para tipos de valor)","text":"<p>En muchos lenguajes de programaci\u00f3n, incluido el pseudoc\u00f3digo que estamos utilizando, es importante manejar la posibilidad de que una variable no tenga un valor asignado, es decir, que sea <code>null</code>. Esto es especialmente relevante para evitar errores en tiempo de ejecuci\u00f3n cuando se intenta acceder a una variable que no ha sido inicializada. Null implica que la variable no apunta a ning\u00fan valor v\u00e1lido en memoria.</p> <ul> <li>Los tipos de valor (como <code>int</code>, <code>decimal</code>, <code>bool</code>) no pueden ser <code>null</code> por defecto. Para permitir que almacenen la ausencia de valor (nulo), se les puede a\u00f1adir el s\u00edmbolo <code>?</code>.</li> <li>Los tipos de referencia (como <code>string</code>) pueden ser <code>null</code> por defecto.</li> </ul> <pre><code>Main() {\n  int? numeroNulo = null; // Un entero que puede ser nulo\n  string textoOpcional = null; // Una cadena que puede ser nula\n\n  if (numeroNulo == null) {\n      writeLine(\"NumeroNulo es nulo.\");\n  }\n\n  if (textoOpcional == null) {\n      writeLine(\"TextoOpcional es nulo.\");\n  }\n}\n</code></pre>"},{"location":"temas/01/index.html#33-variables-constantes-y-literales","title":"3.3. Variables, Constantes y Literales","text":""},{"location":"temas/01/index.html#331-identificadores-y-palabras-reservadas","title":"3.3.1. Identificadores y Palabras Reservadas","text":"<ul> <li> <p>Identificadores: Son los nombres que se les dan a las variables, constantes, funciones y otros elementos en un programa. Un identificador es una secuencia de letras y d\u00edgitos, donde el primer s\u00edmbolo debe ser una letra, un guion bajo (<code>_</code>) o el s\u00edmbolo de d\u00f3lar (<code>$</code>). En el pseudoc\u00f3digo se recomienda seguir convenciones de nomenclatura como <code>camelCase</code> para variables y funciones (ej. <code>nombreVariable</code>) y may\u00fasculas con guiones bajos para constantes (ej. <code>MAX_VALUE</code>).</p> <p>Reglas y Convenciones para Identificadores</p> <ul> <li> <p>Reglas Obligatorias:</p> <ul> <li>Comienza con una letra, <code>_</code> o <code>$</code>.</li> <li>No incluye espacios en blanco.</li> <li>No puede ser una palabra reservada ni los literales <code>true</code>, <code>false</code>, <code>null</code>.</li> <li>Es sensible a may\u00fasculas y min\u00fasculas (ej. <code>edad</code> y <code>Edad</code> son distintos).</li> <li>Puede tener cualquier longitud.</li> </ul> </li> <li> <p>Convenciones Recomendadas (pseudoc\u00f3digo):</p> <ul> <li>Variables: <code>camelCase</code> (ej. <code>cantidadAlumnos</code>, <code>longitudPiscina</code>).</li> <li>Constantes: <code>MAYUSCULAS_CON_GUIONES_BAJOS</code> (ej. <code>MAXIMO_PLANTAS</code>, <code>PI</code>).</li> <li>Nombres de Funciones/M\u00e9todos: <code>camelCase</code> (ej. <code>calculaArea()</code>, <code>obtenerDato()</code>).</li> <li>Evitar <code>$</code> o <code>_</code> al principio para identificadores de usuario.</li> </ul> </li> </ul> </li> <li> <p>Palabras Reservadas: Son secuencias de caracteres cuyo uso est\u00e1 reservado por el lenguaje y no pueden utilizarse para crear identificadores. Ejemplos de palabras reservadas pueden incluir <code>const</code>, <code>var</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>true</code>, <code>false</code>, <code>int</code>, <code>decimal</code>, <code>string</code>, <code>bool</code>, <code>Funcion</code>, <code>Main</code>, <code>enum</code>, <code>writeLine</code>, <code>readLine</code>, etc..</p> <p>Palabras Reservadas y Literales Especiales</p> Categor\u00eda Palabras / Literales Descripci\u00f3n Tipos de datos <code>int</code>, <code>decimal</code>, <code>string</code>, <code>bool</code> Tipos de datos primitivos. Modificadores <code>const</code>, <code>var</code>, <code>readonly</code> Para constantes, inferencia de tipos, variables de solo lectura. Control de flujo <code>if</code>, <code>else</code>, <code>switch</code>, <code>for</code>, <code>while</code>, <code>do</code> Estructuras para la l\u00f3gica del programa. Funciones <code>Funcion</code>, <code>Main</code>, <code>writeLine</code>, <code>readLine</code> Para definir funciones, el punto de entrada, salida y entrada. Literales <code>true</code>, <code>false</code>, <code>null</code> Valores booleanos y valor nulo. Enumeraciones <code>enum</code> Para definir tipos enumerados. </li> </ul>"},{"location":"temas/01/index.html#332-variables-concepto-declaracion-e-inicializacion-inferencia-de-tipos-var","title":"3.3.2. Variables: Concepto, Declaraci\u00f3n e Inicializaci\u00f3n, Inferencia de Tipos (<code>var</code>)","text":"<p>Una variable es un contenedor cuyo valor puede cambiar a lo largo de la ejecuci\u00f3n de un programa. *   Concepto: Representan valores en el programa y tienen atributos como nombre (identificador), tipo, valor y mutabilidad. *   Declaraci\u00f3n e Inicializaci\u00f3n: Antes de usar una variable, debe ser declarada, indicando su identificador y su tipo de dato. Opcionalmente, se puede inicializar asign\u00e1ndole un valor inicial en el momento de la declaraci\u00f3n o posteriormente.</p> <p></p><pre><code>Main() {\n  int cantidadLargos = 10;           // Declaraci\u00f3n e inicializaci\u00f3n\n  decimal longitudPiscina;            // Declarada pero no inicializada\n  string nombre = \"Juan\";            // Declaraci\u00f3n e inicializaci\u00f3n\n  bool encontrado = false;           // Declaraci\u00f3n e inicializaci\u00f3n\n  int edad;                          // Declaraci\u00f3n\n  edad = 30;                         // Inicializaci\u00f3n posterior\n}\n</code></pre> *   Inferencia de Tipos (<code>var</code>): El pseudoc\u00f3digo permite usar la palabra clave <code>var</code> para que el sistema infiera el tipo de la variable a partir del valor que se le asigna. Cuando se usa <code>var</code>, la variable siempre debe ser inicializada al declararse.<p></p> <pre><code>Main() {\n  var edad = 30;         // El sistema infiere que es de tipo int\n  var precio = 99.99;    // El sistema infiere que es de tipo decimal\n  var mensaje = \"Hola\";  // El sistema infiere que es de tipo string\n}\n</code></pre>"},{"location":"temas/01/index.html#333-constantes-const-y-variables-de-solo-lectura-readonly","title":"3.3.3. Constantes (<code>const</code>) y Variables de solo lectura (<code>readonly</code>)","text":"<ul> <li>Constantes (<code>const</code>): Son valores fijos que no pueden cambiar su contenido a lo largo de la ejecuci\u00f3n del programa. Deben ser inicializadas al declararse. Se utilizan para facilitar la modificabilidad de programas y dar nombre a valores concretos. Se conocen como constantes literales (tiempo de compilaci\u00f3n).</li> </ul> <pre><code>Main() {\n  const int MAXIMO_NUMERO_PLANTAS = 12;\n  const decimal PI = 3.1415926536;\n\n  writeLine(\"El n\u00famero m\u00e1ximo de plantas es: \" + MAXIMO_NUMERO_PLANTAS);\n  writeLine(\"El valor de PI es: \" + PI);\n}\n</code></pre> <ul> <li>Variables de solo lectura (<code>readonly</code>): Se inicializan una sola vez y su valor no puede ser modificado despu\u00e9s. A diferencia de <code>const</code>, el valor puede ser asignado en tiempo de ejecuci\u00f3n.</li> </ul>"},{"location":"temas/01/index.html#334-literales-concepto-y-ejemplos-booleanos-enteros-caracteres-cadenas","title":"3.3.4. Literales: Concepto y ejemplos (booleanos, enteros, caracteres, cadenas)","text":"<p>Un literal, valor literal o constante literal es un valor concreto que se escribe directamente en el c\u00f3digo.</p> <ul> <li>Literales booleanos: Son <code>true</code> y <code>false</code>.</li> <li>Literales num\u00e9ricos: Son los n\u00fameros que se escriben directamente, como <code>12</code> (entero), <code>3.14</code> (real). Se pueden usar <code>_</code> para mejorar la legibilidad.</li> <li>Literales de cadenas: Una secuencia de caracteres encerrada entre comillas dobles, como <code>\"Hola Mundo\"</code>.</li> </ul> <pre><code>Main() {\n  // Literales booleanos\n  bool estaActivo = true;\n  bool tienePermiso = false;\n\n  // Literales num\u00e9ricos (enteros y reales)\n  int numeroEntero = 123;\n  decimal numeroReal = 45.67;\n  decimal numeroCientifico = 1.23E+5; // 123000.0\n\n  // Literales de cadena\n  string saludo = \"Hola, \";\n  string nombre = \"Mundo\";\n  string fraseCompleta = saludo + nombre + \"!\";\n\n  writeLine(\"Activo: \" + estaActivo);\n  writeLine(\"Permiso: \" + tienePermiso);\n  writeLine(\"Entero: \" + numeroEntero);\n  writeLine(\"Real: \" + numeroReal);\n  writeLine(\"Cient\u00edfico: \" + numeroCientifico);\n  writeLine(\"Frase: \" + fraseCompleta);\n}\n</code></pre>"},{"location":"temas/01/index.html#34-conversiones-de-tipo","title":"3.4. Conversiones de Tipo","text":"<p>Las conversiones de tipo son procesos que permiten cambiar un valor de un tipo de dato a otro.</p> <ul> <li> <p>Conversiones Impl\u00edcitas (Autom\u00e1ticas): Ocurren autom\u00e1ticamente cuando se asigna un valor de un tipo num\u00e9rico a una variable de otro tipo num\u00e9rico que puede contenerlo sin p\u00e9rdida de datos. Por ejemplo, asignar un <code>int</code> a un <code>decimal</code>. En operaciones aritm\u00e9ticas con valores de distinto tipo, el valor m\u00e1s peque\u00f1o se \"promociona\" al tipo m\u00e1s grande.</p> <pre><code>Main() {\n    int entero = 10;\n    decimal real;\n\n    real = entero; // Conversi\u00f3n impl\u00edcita: int (4 bytes) a decimal (8 bytes)\n\n    writeLine(\"Entero: \" + entero);   // Salida: Entero: 10\n    writeLine(\"Real (impl\u00edcito): \" + real); // Salida: Real (impl\u00edcito): 10.0\n}\n</code></pre> </li> <li> <p>Conversiones Expl\u00edcitas (Casting): Se deben indicar de forma manual cuando hay una posible p\u00e9rdida de datos (ej. de un tipo con m\u00e1s bits a uno con menos bits). Esto se hace colocando el tipo de dato deseado entre par\u00e9ntesis delante del valor o expresi\u00f3n a convertir. Hay que tener cuidado con el casting, ya que puede suponer p\u00e9rdida de precisi\u00f3n.</p> <p></p><pre><code>Main() {\n    decimal real = 15.75M;\n    int entero;\n\n    entero = (int)real; // Conversi\u00f3n expl\u00edcita (casting): decimal (8 bytes) a int (4 bytes).\n                        // Se pierde la parte decimal (.75)\n\n    writeLine(\"Real: \" + real);           // Salida: Real: 15.75\n    writeLine(\"Entero (expl\u00edcito): \" + entero); // Salida: Entero (expl\u00edcito): 15\n}\n</code></pre> Tambi\u00e9n para convertir entradas de <code>string</code> a <code>int</code> o <code>decimal</code>: <pre><code>Main() {\n    writeLine(\"Introduce un n\u00famero entero:\");\n    string entradaTexto = ReadLine();\n    int numero = (int)entradaTexto; // Conversi\u00f3n expl\u00edcita de string a int (asumiendo valor v\u00e1lido)\n    writeLine(\"N\u00famero introducido: \" + numero);\n}\n</code></pre><p></p> </li> </ul> <p>Conversiones de Tipos Primitivos (Pseudoc\u00f3digo)</p> Tipo Destino <code>bool</code> <code>int</code> <code>decimal</code> <code>string</code> <code>bool</code> - C C C <code>int</code> N - C C <code>decimal</code> N CI - C <code>string</code> CI CI CI - <ul> <li>CI: Conversi\u00f3n Impl\u00edcita (autom\u00e1tica).</li> <li>C: Conversi\u00f3n Expl\u00edcita (Casting).</li> <li>N: No es posible la conversi\u00f3n directa (o no tiene sentido).<ul> <li>Nota: La conversi\u00f3n a/desde <code>string</code> generalmente implica funciones espec\u00edficas para analizar (<code>Parse</code>) o formatear (<code>ToString</code>) que se realizar\u00edan con casting si el lenguaje lo permite de forma concisa.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#35-operadores-y-expresiones","title":"3.5. Operadores y Expresiones","text":""},{"location":"temas/01/index.html#351-concepto-de-operador-y-expresion","title":"3.5.1. Concepto de Operador y Expresi\u00f3n","text":"<ul> <li>Un operador es un s\u00edmbolo que lleva a cabo operaciones sobre uno o m\u00e1s datos u operandos. Los operadores pueden ser unarios (un operando), binarios (dos operandos) o ternarios (tres operandos). Act\u00faan sobre los tipos de datos y devuelven un resultado de un tipo determinado.</li> <li>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa produciendo un \u00fanico resultado de un tipo determinado. Las expresiones pueden ser parte de otras expresiones o sentencias.</li> </ul>"},{"location":"temas/01/index.html#352-tipos-de-operadores","title":"3.5.2. Tipos de Operadores","text":"<ul> <li>Aritm\u00e9ticos: Se utilizan para realizar operaciones matem\u00e1ticas.<ul> <li>Suma (<code>+</code>), Resta (<code>-</code>), Multiplicaci\u00f3n (<code>*</code>), Divisi\u00f3n (<code>/</code>), M\u00f3dulo (<code>%</code>, que devuelve el resto de una divisi\u00f3n).</li> </ul> </li> </ul> <pre><code>Main() {\n  int a = 10, b = 3;\n  int suma = a + b;     // 13\n  int resta = a - b;    // 7\n  int mult = a * b;     // 30\n  decimal div = (decimal)a / b; // 3.333... (con casting para divisi\u00f3n real)\n  int modulo = a % b;   // 1 (resto de 10/3)\n\n  writeLine(\"Suma: \" + suma);\n  writeLine(\"Resta: \" + resta);\n  writeLine(\"Multiplicaci\u00f3n: \" + mult);\n  writeLine(\"Divisi\u00f3n: \" + div);\n  writeLine(\"M\u00f3dulo: \" + modulo);\n}\n</code></pre> <ul> <li>Relacionales (o de Comparaci\u00f3n): Comparan dos operandos y devuelven un valor booleano (<code>true</code> o <code>false</code>).<ul> <li>Igual a (<code>==</code>), Diferente de (<code>!=</code>), Mayor que (<code>&gt;</code>), Menor que (<code>&lt;</code>), Mayor o igual que (<code>&gt;=</code>), Menor o igual que (<code>&lt;=</code>).</li> </ul> </li> </ul> <pre><code>Main() {\n  int x = 5, y = 10;\n  bool igual = (x == y);      // false\n  bool diferente = (x != y);  // true\n  bool mayor = (x &gt; y);       // false\n  bool menor = (x &lt; y);       // true\n  bool mayorIgual = (x &gt;= 5); // true\n  bool menorIgual = (y &lt;= 10);// true\n\n  writeLine(\"X igual a Y: \" + igual);\n  writeLine(\"X diferente de Y: \" + diferente);\n  // ...\n}\n</code></pre> <ul> <li> <p>L\u00f3gicos: Realizan operaciones sobre valores booleanos o resultados de expresiones relacionales, devolviendo un valor booleano.</p> <ul> <li>AND (<code>&amp;&amp;</code>): Verdadero si ambas condiciones son verdaderas.</li> <li>OR (<code>||</code>): Verdadero si al menos una condici\u00f3n es verdadera.</li> <li>NOT (<code>!</code>): Invierte el resultado de una condici\u00f3n.</li> </ul> Operadores L\u00f3gicos y Tablas de Verdad A B <code>NOT A</code> <code>A AND B</code> <code>A OR B</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <pre><code>Main() {\nbool condicion1 = (10 &gt; 5);   // true\nbool condicion2 = (3 == 4);   // false\n\nbool resultadoAND = condicion1 &amp;&amp; condicion2; // false\nbool resultadoOR = condicion1 || condicion2;  // true\nbool resultadoNOT = !condicion1;              // false\n\nwriteLine(\"AND: \" + resultadoAND);\nwriteLine(\"OR: \" + resultadoOR);\nwriteLine(\"NOT: \" + resultadoNOT);\n}\n</code></pre> </li> <li> <p>De Asignaci\u00f3n: Se utilizan para asignar un valor a una variable.</p> <ul> <li>Asignaci\u00f3n simple (<code>=</code>).</li> <li>Asignaciones compuestas (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, que realizan la operaci\u00f3n y luego asignan el resultado).</li> </ul> <pre><code>Main() {\nint numero = 5;\nnumero += 3; // Equivalente a numero = numero + 3; (numero ahora es 8)\nnumero *= 2; // Equivalente a numero = numero * 2; (numero ahora es 16)\n\nwriteLine(\"Numero: \" + numero); // Salida: Numero: 16\n}\n</code></pre> </li> <li> <p>Operador Alfanum\u00e9rico (Concatenaci\u00f3n <code>+</code>): Se utiliza para concatenar (unir) datos de tipo cadena. Tambi\u00e9n puede usarse para combinar cadenas con otros tipos de datos, convirtiendo estos \u00faltimos a cadena autom\u00e1ticamente.</p> <pre><code>Main() {\nstring saludo = \"Hola\";\nstring nombre = \"Ana\";\nstring mensaje = saludo + \", \" + nombre + \"!\"; // Concatenaci\u00f3n\n\nint edad = 25;\nstring info = \"Tu edad es: \" + edad; // Concatena string con int\n\nwriteLine(mensaje); // Salida: Hola, Ana!\nwriteLine(info);    // Salida: Tu edad es: 25\n}\n</code></pre> </li> <li> <p>Especiales:</p> <ul> <li> <p>Ternario (<code>? :</code>): Eval\u00faa una condici\u00f3n y devuelve un resultado u otro en funci\u00f3n de si es verdadera o falsa. Es el \u00fanico operador ternario.</p> <ul> <li>Sintaxis: <code>condicion ? valorSiVerdadero : valorSiFalso;</code>.</li> </ul> <pre><code>Main() {\n    int x = 10, y = 5;\n    string resultado = (x &gt; y) ? \"X es mayor\" : \"Y es mayor o igual\";\n    writeLine(resultado); // Salida: X es mayor\n\n    int maximo = (x &gt; y) ? x : y;\n    writeLine(\"El m\u00e1ximo es: \" + maximo); // Salida: El m\u00e1ximo es: 10\n}\n</code></pre> </li> </ul> </li> <li> <p>Operador de Nulidad (<code>??</code>): Devuelve el valor del operando de la izquierda si no es nulo; de lo contrario, devuelve el de la derecha. \u00datil para proporcionar un valor predeterminado.</p> <pre><code>Main() {\n    string? nombreUsuario = null;\n    string nombreAMostrar = nombreUsuario ?? \"Invitado\"; // Si nombreUsuario es null, usa \"Invitado\"\n    writeLine(\"Bienvenido, \" + nombreAMostrar); // Salida: Bienvenido, Invitado\n\n    nombreUsuario = \"Mar\u00eda\";\n    nombreAMostrar = nombreUsuario ?? \"Invitado\";\n    writeLine(\"Bienvenido, \" + nombreAMostrar); // Salida: Bienvenido, Mar\u00eda\n}\n</code></pre> </li> </ul> Avanzado: Leyes de De Morgan <p>Las Leyes de De Morgan son reglas que te permiten simplificar expresiones l\u00f3gicas y son muy \u00fatiles al trabajar con condiciones en programaci\u00f3n. B\u00e1sicamente, te dicen c\u00f3mo la negaci\u00f3n de una expresi\u00f3n compleja puede ser \"distribuida\" entre sus componentes.</p> Primera Ley de De MorganSegunda Ley de De Morgan <p>La negaci\u00f3n de una conjunci\u00f3n (<code>AND</code>) es equivalente a la disyunci\u00f3n (<code>OR</code>) de las negaciones de sus componentes. En otras palabras, \"no A y B\" es lo mismo que \"no A o no B\".</p> <ul> <li>Expresi\u00f3n original: <code>!(A &amp;&amp; B)</code></li> <li>Equivalente: <code>!A || !B</code></li> </ul> A B <code>A AND B</code> <code>NOT (A AND B)</code> <code>NOT A</code> <code>NOT B</code> <code>NOT A OR NOT B</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>true</code> <p>La negaci\u00f3n de una disyunci\u00f3n (<code>OR</code>) es equivalente a la conjunci\u00f3n (<code>AND</code>) de las negaciones de sus componentes. Dicho de otro modo, \"no A o B\" es lo mismo que \"no A y no B\".</p> <ul> <li>Expresi\u00f3n original: <code>!(A || B)</code></li> <li>Equivalente: <code>!A &amp;&amp; !B</code></li> </ul> A B <code>A OR B</code> <code>NOT (A OR B)</code> <code>NOT A</code> <code>NOT B</code> <code>NOT A AND NOT B</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>true</code>"},{"location":"temas/01/index.html#353-precedencia-de-operadores-y-asociatividad","title":"3.5.3. Precedencia de Operadores y Asociatividad","text":"<ul> <li>Precedencia: Es la prioridad de los operadores, que determina el orden en que se eval\u00faan en una expresi\u00f3n. Por ejemplo, la multiplicaci\u00f3n y divisi\u00f3n tienen mayor precedencia que la suma y resta.</li> <li>Asociatividad: Indica qu\u00e9 operador se eval\u00faa primero en caso de que varios operadores tengan la misma precedencia. Generalmente, la mayor\u00eda son asociativos por la izquierda (se eval\u00faan de izquierda a derecha), mientras que los de asignaci\u00f3n y el condicional son asociativos por la derecha. El uso de par\u00e9ntesis <code>()</code> puede modificar el orden de evaluaci\u00f3n, forzando una precedencia espec\u00edfica y mejorando la legibilidad.</li> </ul> <p>Precedencia de Operadores (Pseudoc\u00f3digo DAW)</p> Operador Tipo Asociatividad <code>( )</code> Agrupaci\u00f3n - <code>!</code> L\u00f3gico Unario Derecha <code>* / %</code> Aritm\u00e9ticos Izquierda <code>+ -</code> Aritm\u00e9ticos Izquierda <code>&lt; &lt;= &gt; &gt;=</code> Relacionales Izquierda <code>== !=</code> Relacionales Izquierda <code>&amp;&amp;</code> L\u00f3gico AND Izquierda <code>|                      |</code> L\u00f3gico OR Izquierda <code>? :</code> Condicional Ternario Derecha <code>= += -= *= /= %= ??</code> Asignaci\u00f3n y Nulidad Derecha"},{"location":"temas/01/index.html#36-comentarios-y-documentacion-basica-del-codigo","title":"3.6. Comentarios y Documentaci\u00f3n B\u00e1sica del C\u00f3digo","text":"<p>Importancia y tipos de Comentarios (una l\u00ednea <code>//</code>, m\u00faltiples l\u00edneas <code>/* */</code>) Los comentarios son notas que los programadores dejan en el c\u00f3digo para explicar su funcionamiento, describir el programa, o cualquier otra indicaci\u00f3n \u00fatil. El programa ignora los comentarios durante su ejecuci\u00f3n. Son esenciales para la legibilidad, el desarrollo y el mantenimiento colaborativo.</p> <p>Los tipos de comentarios comunes en el pseudoc\u00f3digo DAW son:</p> <ul> <li> <p>Comentarios de una sola l\u00ednea (<code>//</code>): Se inician con dos barras y afectan el texto hasta el final de esa l\u00ednea.</p> <p></p><pre><code>// Esto es un comentario de una sola l\u00ednea\n</code></pre> *   Comentarios de m\u00faltiples l\u00edneas (<code>/* */</code>): Se inician con <code>/*</code> y finalizan con <code>*/</code>, abarcando varias l\u00edneas.<p></p> <pre><code>/*\nEsto es un comentario\nque ocupa\nvarias l\u00edneas.\n*/\n</code></pre> </li> </ul> <p>Documentaci\u00f3n Interna del C\u00f3digo</p> <p>La documentaci\u00f3n interna se refiere a los comentarios, encabezados, descripciones y declaraciones del problema que se incluyen directamente dentro del c\u00f3digo fuente. Una buena pr\u00e1ctica es que cada programa comience con comentarios que indiquen, al menos, una breve descripci\u00f3n del programa, el autor y la \u00faltima fecha de modificaci\u00f3n. Adem\u00e1s, en el pseudoc\u00f3digo, como en lenguajes como Java con Javadoc, podr\u00edan emplearse comentarios especiales (<code>/** */</code>) para generar documentaci\u00f3n autom\u00e1tica del programa a partir del c\u00f3digo fuente.</p> <pre><code>/**\n * Nombre del Programa: CalculadoraSimple\n * Autor: [Tu Nombre]\n * Fecha de \u00daltima Modificaci\u00f3n: 2024-10-27\n * Descripci\u00f3n: Este programa realiza operaciones aritm\u00e9ticas b\u00e1sicas\n *              solicitando dos n\u00fameros al usuario.\n */\nMain() {\n  // Declaraci\u00f3n de variables\n  int num1; // Primer n\u00famero introducido por el usuario\n  int num2; // Segundo n\u00famero introducido por el usuario\n  int resultadoSuma; /* Variable para almacenar\n                          el resultado de la suma */\n\n  // El resto del c\u00f3digo del programa ir\u00eda aqu\u00ed\n}\n</code></pre>"},{"location":"temas/01/index.html#4-el-lenguaje-de-programacion-pseudocodigo-daw","title":"4. El Lenguaje de Programaci\u00f3n Pseudoc\u00f3digo DAW","text":"<p>El pseudoc\u00f3digo DAW es un lenguaje de programaci\u00f3n dise\u00f1ado para ser sencillo y f\u00e1cil de entender, ideal para principiantes en programaci\u00f3n. Combina elementos de varios lenguajes de programaci\u00f3n populares, como C#, Java y Python, para ofrecer una sintaxis clara y concisa.</p> <p>Se usar\u00e1 para aprender los conceptos fundamentales de la programaci\u00f3n antes de pasar a lenguajes m\u00e1s complejos y con ello facilitar la transici\u00f3n a lenguajes de programaci\u00f3n reales. Con \u00e9l se pueden crear programas estructurados y modulares y resolver problemas de programaci\u00f3n comunes.</p> <p>Esta gu\u00eda proporciona una visi\u00f3n general de los conceptos b\u00e1sicos del lenguaje DAW, dise\u00f1ado para ser sencillo y f\u00e1cil de aprender. Este lenguaje es ideal para principiantes en programaci\u00f3n, ya que combina elementos de lenguajes populares como C#, Java, Kotlin y JavaScript, adaptados a un entorno educativo.</p> <p>Se usar\u00e1 como base para aprender los fundamentos de la programaci\u00f3n estructurada y modular y servir\u00e1 como base para aprender otros lenguajes m\u00e1s complejos en el futuro.</p> <p>A continuaci\u00f3n, se describen los elementos fundamentales que componen este lenguaje.</p>"},{"location":"temas/01/index.html#a-comentarios","title":"A. Comentarios","text":"<p>Los comentarios son notas que el programa ignora. Sirven para explicar el c\u00f3digo a otros desarrolladores o a ti mismo.</p> <ul> <li>Comentario de una l\u00ednea: Se inicia con dos barras (<code>//</code>).     <pre><code>// Esto es un comentario de una sola l\u00ednea.\nint edad = 30; // Tambi\u00e9n se puede poner al final de una l\u00ednea de c\u00f3digo.\n</code></pre></li> <li>Comentario de varias l\u00edneas: Se inicia con <code>/*</code> y finaliza con <code>*/</code>.     <pre><code>/*\nEste es un comentario\nque se extiende\npor varias l\u00edneas.\n*/\n</code></pre></li> </ul>"},{"location":"temas/01/index.html#b-estructura-del-programa","title":"B. Estructura del Programa","text":"<p>El punto de entrada ser\u00e1 un bloque principal llamado <code>Main()</code>, donde se escribir\u00e1 todo el c\u00f3digo que se ejecutar\u00e1 al iniciar el programa.  Este bloque es obligatorio en todos los programas. Todo programa debe tener este bloque principal, que contiene las instrucciones que se ejecutan al iniciar el programa. Es decir, la l\u00f3gica del programa y/o algoritmo se escribe dentro de este bloque.</p> <pre><code>Main() {\n    // Aqu\u00ed va el c\u00f3digo de nuestro programa.\n    // Es el primer c\u00f3digo que se ejecuta.\n}\n</code></pre>"},{"location":"temas/01/index.html#c-variables-constantes-y-literales","title":"C. Variables, Constantes y Literales","text":"<p>Seguiremos la convenci\u00f3n de nomenclatura <code>camelCase</code> (<code>ejemploVariable</code>, <code>nombreUsuario</code>).</p> <ul> <li>Variables: Son contenedores cuyo valor puede cambiar. Se declaran con un tipo de dato y un nombre.     <pre><code>int edad;\nint contador = 0;\nstring nombre = \"Ana\";\n</code></pre></li> <li>Inferencia de Tipos con <code>var</code>: Con <code>var</code>, el sistema infiere el tipo de la variable a partir del valor que se le asigna. Esto hace que el c\u00f3digo sea m\u00e1s corto y legible. La \u00fanica regla es que siempre debes inicializar la variable cuando usas <code>var</code>.     <pre><code>var edad = 30;       // Se infiere que 'edad' es de tipo int.\nvar nombreCompleto = \"Juan P\u00e9rez\";  // Se infiere que es de tipo string.\n</code></pre></li> <li>Variables que almacenan nulos: Para los tipos que normalmente no pueden ser <code>null</code> (como <code>int</code> o <code>bool</code>), se les puede a\u00f1adir el s\u00edmbolo <code>?</code> para permitirles almacenar la ausencia de valor. Los tipos de referencia como <code>string</code> ya pueden ser <code>null</code> por defecto.     <pre><code>int? edadOpcional = null;\nstring apellido = null; // Un string ya puede ser nulo por defecto\n</code></pre></li> <li>Conversiones entre Tipos:<ul> <li>Conversi\u00f3n Impl\u00edcita: Ocurre autom\u00e1ticamente cuando se asigna un valor a una variable de un tipo que puede contenerlo sin p\u00e9rdida de datos.     <pre><code>int numeroInt = 10;\ndecimal numeroDecimal = numeroInt; // Conversi\u00f3n impl\u00edcita de int a decimal.\n</code></pre></li> <li>Conversi\u00f3n Expl\u00edcita (Casting): Se debe indicar de forma manual cuando hay una posible p\u00e9rdida de datos. Se hace colocando el tipo de dato entre par\u00e9ntesis delante del valor.     <pre><code>decimal numeroDecimal = 10.75m;\nint numeroInt = (int)numeroDecimal; // Conversi\u00f3n expl\u00edcita, se pierde el .75\nwriteLine(numeroInt); // Muestra 10\n</code></pre></li> </ul> </li> <li>Constantes: Son valores fijos que no pueden cambiar. Se utiliza la palabra clave <code>const</code> y deben ser inicializados al declararse.     <pre><code>const decimal PI = 3.14159m;\n</code></pre></li> <li>Variables de solo lectura: Se inicializan una sola vez y su valor no puede ser modificado despu\u00e9s. Usamos la palabra clave <code>readonly</code>.     <pre><code>readonly string version = \"1.0\";\n</code></pre></li> <li>Literales: Son valores fijos que se escriben directamente en el c\u00f3digo (n\u00fameros, texto entre comillas, o los valores <code>true</code> y <code>false</code>).</li> </ul>"},{"location":"temas/01/index.html#d-tipos-de-datos-y-control-de-nulos","title":"D. Tipos de Datos y Control de Nulos","text":"<p>Los tipos de datos que m\u00e1s utilizaremos son <code>int</code>, <code>decimal</code>, <code>string</code> y <code>bool</code>.</p> <ul> <li> <p><code>int</code> (Entero): Almacena n\u00fameros enteros sin decimales, positivos y negativos. Se utiliza para contar o en operaciones matem\u00e1ticas sin fracciones.</p> <ul> <li>Valores: de <code>2.147.483.648</code> a <code>2.147.483.647</code> (aprox.).</li> <li>Operaciones: Suma, resta, multiplicaci\u00f3n, divisi\u00f3n, etc.</li> </ul> </li> <li> <p><code>decimal</code> (Decimal): Almacena n\u00fameros con decimales. Se usa para operaciones financieras o cient\u00edficas que requieren alta precisi\u00f3n. A diferencia de <code>decimal</code>, no tiene la \"m\" al final por defecto, pero es una buena pr\u00e1ctica a\u00f1adirla para indicar expl\u00edcitamente que es un literal de tipo decimal.</p> <ul> <li>Valores: Con hasta 28 o 29 d\u00edgitos decimales de precisi\u00f3n.</li> <li>Operaciones: Las mismas que los enteros, pero con manejo de decimales.</li> </ul> </li> <li> <p><code>string</code> (Cadena): Almacena una secuencia de caracteres. Se utiliza para texto, nombres, frases.</p> <ul> <li>Valores: Cualquier texto entre comillas dobles.</li> <li>Operaciones: Concatenaci\u00f3n (<code>+</code>), b\u00fasqueda de subcadenas, etc.</li> </ul> </li> <li> <p><code>bool</code> (Booleano): Almacena un valor l\u00f3gico. Se utiliza para condiciones de verdadero o falso.</p> <ul> <li>Valores: Solo <code>true</code> o <code>false</code>.</li> <li>Operaciones: Operadores l\u00f3gicos (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>).</li> </ul> </li> <li> <p>Los tipos de valor (<code>int</code>, <code>decimal</code>, <code>bool</code>, etc.) no pueden ser <code>null</code> a menos que se use el operador <code>?</code>.</p> </li> <li> <p>Los tipos de referencia (<code>string</code>) pueden ser <code>null</code> por defecto.</p> </li> </ul>"},{"location":"temas/01/index.html#e-enumeraciones-enum","title":"E. Enumeraciones (<code>enum</code>)","text":"<p>Una enumeraci\u00f3n es un tipo de dato que consiste en un conjunto de constantes nombradas. Se utiliza para hacer el c\u00f3digo m\u00e1s legible y menos propenso a errores, ya que en lugar de usar n\u00fameros \"m\u00e1gicos\" (como <code>1</code> o <code>2</code>), se usan nombres con significado.</p> <ul> <li>Sintaxis: <pre><code>enum DiasSemana {\n    Lunes,     // Se le asigna 0 por defecto\n    Martes,    // Se le asigna 1 por defecto\n    Miercoles,\n    Jueves,\n    Viernes,\n    Sabado,\n    Domingo\n}\n</code></pre></li> <li>Ejemplo de uso: <pre><code>Main() {\n    var hoy = DiasSemana.Miercoles;\n\n    if (hoy == DiasSemana.Miercoles) {\n        writeLine(\"Hoy es mitad de semana\");\n    }\n}\n</code></pre></li> </ul>"},{"location":"temas/01/index.html#f-operadores","title":"F. Operadores","text":"<ul> <li> <p>Operadores Matem\u00e1ticos:</p> <ul> <li><code>+</code> : Suma</li> <li><code>-</code> : Resta</li> <li><code>*</code> : Multiplicaci\u00f3n</li> <li><code>/</code> : Divisi\u00f3n</li> <li><code>%</code> : M\u00f3dulo (devuelve el resto de una divisi\u00f3n)</li> </ul> <p></p> </li> <li> <p>Operadores de Asignaci\u00f3n: Sirven para asignar un valor a una variable.</p> <ul> <li><code>=</code> : Asigna el valor (ej: <code>x = 5;</code>)</li> <li><code>+=</code> : Suma y asigna</li> <li><code>-=</code> : Resta y asigna</li> <li><code>*=</code> : Multiplica y asigna</li> <li><code>/=</code> : Divide y asigna</li> </ul> <p></p> </li> <li> <p>Operadores L\u00f3gicos y de Comparaci\u00f3n:</p> <ul> <li><code>==</code> : Es igual a</li> <li><code>!=</code> : Es diferente de</li> <li><code>&gt;</code> : Mayor que</li> <li><code>&lt;</code> : Menor que</li> <li><code>&gt;=</code> : Mayor o igual que</li> <li><code>&lt;=</code> : Menor o igual que</li> <li><code>&amp;&amp;</code> (AND): Verdadero si ambas condiciones son verdaderas.</li> <li><code>||</code> (OR): Verdadero si al menos una condici\u00f3n es verdadera.</li> <li><code>!</code> (NOT): Invierte el resultado de una condici\u00f3n.</li> </ul> <p></p> </li> <li> <p>Operadores Especiales:</p> <ul> <li>Operador Ternario (<code>? :</code>): Es una forma abreviada de escribir una sentencia <code>if-else</code> simple.<ul> <li>Sintaxis: <code>condicion ? valorSiVerdadero : valorSiFalso;</code> <pre><code>var esMayorDeEdad = (edad &gt;= 18) ? \"S\u00ed\" : \"No\";\n</code></pre></li> </ul> </li> <li>Operador de Nulidad (<code>??</code>):<ul> <li><code>??</code> (Null-Coalescing): Devuelve el valor del operando de la izquierda si no es nulo; de lo contrario, devuelve el de la derecha. Es \u00fatil para proporcionar un valor predeterminado.  <pre><code>var nombreCompleto = nombre ?? \"Desconocido\";\n</code></pre></li> </ul> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#g-entrada-y-salida","title":"G. Entrada y Salida","text":"<ul> <li>Salida (<code>writeLine</code>): Muestra texto en la consola.     <pre><code>writeLine(\"Hola, esto es un mensaje.\");\nvar resultado = 10;\nwriteLine(\"El resultado es: \" + resultado);\n</code></pre></li> <li>Entrada (<code>readLine</code> y casting): Lee una cadena de texto desde la consola. Se debe hacer un casting expl\u00edcito para convertirla a otro tipo, asumiendo que el valor es v\u00e1lido.     <pre><code>writeLine(\"Introduce tu edad:\");\n// Se lee una cadena y se convierte a int\nvar edadUsuario = (int)readLine(); \n\nwriteLine(\"Introduce tu peso (en kg):\");\n// Se lee una cadena y se convierte a decimal\nvar pesoUsuario = (decimal)readLine();\n</code></pre></li> </ul> <p>Si recibes la edad de una persona, indica la siguiente informaci\u00f3n: - Si es menor de 0 a\u00f1os =&gt; \"Edad no v\u00e1lida\". - Si es menor de 1 a\u00f1o =&gt; \"Eres un beb\u00e9\". - Si es menor de edad (menos de 18 a\u00f1os) =&gt; \"Eres menor de edad\". - Si es mayor de edad pero menor de 65 a\u00f1os =&gt; \"Eres mayor de edad\". - Si es mayor o igual de 65 a\u00f1os =&gt; \"Eres jubilado\". - Si es mayor de 120 a\u00f1os =&gt; \"Te has pasado el juego\".</p>"},{"location":"temas/01/index.html#h-los-condicionales","title":"H. Los condicionales.","text":"<p>Los condicionales nos permiten ejecutar una parte de c\u00f3digo u otra dependiendo de si se cumple o no una condici\u00f3n. La condici\u00f3n es una expresi\u00f3n que se eval\u00faa como verdadera (<code>true</code>) o falsa (<code>false</code>).</p> <p>Pueden ser:</p> <ul> <li>Condicionales simples: Se ejecuta una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n (if). La parte de c\u00f3digo que se ejecuta se llama rama verdadera y la otra rama falsa. La parte asociada a else es opcional.</li> </ul> <pre><code>// Condicionales simples\nif (edadAlumno &gt;= 18) \n    println(\"Eres mayor de edad\");\nelse \n    println(\"Eres menor de edad\");\n</code></pre> <ul> <li>Condicionales m\u00faltiples: Pueden tener varios casos (if-else-if-else). Se ejecuta una parte de c\u00f3digo u otra dependiendo de una condici\u00f3n.</li> </ul> <pre><code>// Condicionales m\u00faltiples\nif (edadAlumno &gt;= 18) \n    println(\"Eres mayor de edad\")\nelse if (edadAlumno &gt;= 16) \n    println(\"Casi eres mayor de edad\")\nelse \n    println(\"Eres menor de edad\")\n</code></pre> <p>Tambien podemos usar if-m\u00faltiples con una opci\u00f3n m\u00e1s potente, como <code>when</code>:</p> <pre><code>// Condicionales m\u00faltiples\nwhen (edadAlumno) {\n    &gt;18 -&gt; println(\"Eres mayor de edad\")\n    16..18 -&gt; println(\"Casi eres mayor de edad\")\n\n    else -&gt; println(\"Eres menor de edad\")\n}\n</code></pre>"},{"location":"temas/01/index.html#i-bucles-o-iteradores","title":"I. Bucles o Iteradores","text":"<p>Los bucles o iteradores nos permiten ejecutar una parte de c\u00f3digo varias veces. Existen varios tipos.</p> <p></p> <pre><code>// Bucles indefinidos\n// Ejemplo while\nvar i = 0\nwhile (i &lt; 10) {\n    println(i)\n    i++\n}\n\n// Ejemplo do-while\nvar i = 0\ndo {\n    println(i)\n    i++\n} while (i &lt; 10)\n</code></pre>"},{"location":"temas/02/index.html","title":"02 - Elementos b\u00e1sicos","text":""},{"location":"temas/02/index.html#ut2-elementos-basicos-de-java","title":"UT2. Elementos B\u00e1sicos de Java","text":"<p>En esta secci\u00f3n se abordan los conceptos fundamentales para comenzar a programar en Java, desde la estructura b\u00e1sica de un programa hasta el uso de variables, constantes y operaciones.</p>"},{"location":"temas/02/index.html#21-del-codigo-fuente-a-la-ejecucion","title":"2.1. Del C\u00f3digo Fuente a la Ejecuci\u00f3n","text":"<p>El ciclo de vida de un programa Java sigue un proceso claro:</p> <ol> <li>C\u00f3digo Fuente: Es el archivo de texto con extensi\u00f3n <code>.java</code> que escribe el programador.</li> <li>Compilador: El c\u00f3digo fuente es procesado por el compilador de Java.</li> <li>Bytecode: El compilador traduce el c\u00f3digo a este formato intermedio, que es independiente de la plataforma.</li> <li>Ejecuci\u00f3n: La M\u00e1quina Virtual de Java (JVM) interpreta y ejecuta el Bytecode, produciendo la salida final del programa.</li> </ol> <p>Durante la programaci\u00f3n, se manejan valores b\u00e1sicos como los booleanos <code>true</code> y <code>false</code>, y el valor especial <code>null</code>, que representa la ausencia de un valor</p>"},{"location":"temas/02/index.html#22-comentarios","title":"2.2. Comentarios","text":"<p>Los comentarios son textos dentro del c\u00f3digo fuente que el compilador ignora por completo [1]. Su funci\u00f3n es puramente informativa, permitiendo al programador dejar notas, explicaciones sobre algoritmos complejos o recordatorios para s\u00ed mismo o para otros desarrolladores que trabajen en el mismo c\u00f3digo [1].</p> <p>Ejemplos de comentarios: </p><pre><code>// Esto es un comentario de una sola l\u00ednea.\n\n/*\n  Esto es un comentario\n  de m\u00faltiples l\u00edneas. Se usa para\n  explicaciones m\u00e1s extensas.\n*/\nint edad = 30; // Tambi\u00e9n se puede comentar al final de una l\u00ednea de c\u00f3digo.\n</code></pre><p></p>"},{"location":"temas/02/index.html#23-variables","title":"2.3. Variables","text":"<p>Una variable es un concepto central en la programaci\u00f3n.</p>"},{"location":"temas/02/index.html#231-definicion","title":"2.3.1. Definici\u00f3n","text":"<p>Una variable es una porci\u00f3n de memoria a la que se le asigna un nombre (identificador). Su prop\u00f3sito es almacenar un valor que puede ser utilizado y modificado a lo largo de la ejecuci\u00f3n del programa.</p>"},{"location":"temas/02/index.html#232-reglas-para-nombrar-variables","title":"2.3.2. Reglas para Nombrar Variables","text":"<p>Los identificadores de las variables en Java deben seguir unas reglas espec\u00edficas:</p> <ul> <li> <p>Deben comenzar por una letra (preferiblemente min\u00fascula), el car\u00e1cter de guion bajo (_) o el s\u00edmbolo de d\u00f3lar ($).</p> </li> <li> <p>Despu\u00e9s del primer car\u00e1cter, pueden contener una combinaci\u00f3n de letras, d\u00edgitos, guiones bajos o s\u00edmbolos de d\u00f3lar.</p> </li> <li> <p>Java es Case Sensitive, lo que significa que distingue entre may\u00fasculas y min\u00fasculas.</p> </li> <li> <p>No existe una longitud m\u00e1xima para el nombre de una variable.</p> </li> </ul> <p>Ejemplos:</p> <ul> <li> <p>Nombres v\u00e1lidos: <code>edad</code>, <code>maxValor</code>, <code>notaMediaTrimestre</code>, <code>_usuario</code>, <code>$departamento</code>.</p> </li> <li> <p>Nombres no v\u00e1lidos: <code>1numero</code> (no puede empezar por un d\u00edgito), <code>nota-media</code> (no se permite el guion medio), <code>class</code> (es una palabra reservada del lenguaje).</p> </li> </ul>"},{"location":"temas/02/index.html#233-tipos-de-datos-y-declaracion","title":"2.3.3. Tipos de Datos y Declaraci\u00f3n","text":"<p>Para usar una variable, primero se debe declarar, indicando su tipo de dato seguido de su nombre. Java ofrece diversos tipos de datos para distintos prop\u00f3sitos, y un mismo valor podr\u00eda ser v\u00e1lido para varios tipos. Es importante destacar que <code>String</code> no es un tipo de dato primitivo como los num\u00e9ricos.</p> <p>Ejemplo de declaraci\u00f3n:</p> <pre><code>// Declaraci\u00f3n de variables de diferentes tipos\nint numeroDeEstudiantes;\ndouble precioProducto;\nboolean esValido;\nchar inicial;\nString nombreUsuario;\n</code></pre>"},{"location":"temas/02/index.html#234-valores-literales","title":"2.3.4. Valores Literales","text":"<p>Los valores literales son valores fijos escritos directamente en el c\u00f3digo. Java los interpreta de la siguiente manera:</p> <ul> <li> <p>Un valor entre comillas dobles (\") es un <code>String</code>. Ejemplo: <code>\"Hola Mundo\"</code>.</p> </li> <li> <p>Un valor entre comillas simples (') es un <code>char</code>. Ejemplo: <code>'A'</code>.</p> </li> <li> <p>Un valor sin comillas es interpretado como num\u00e9rico.</p> </li> <li> <p>Por defecto, un n\u00famero entero es de tipo <code>int</code>. Para indicar que es de tipo <code>long</code>, se a\u00f1ade una <code>l</code> al final. Ejemplo: <code>long numeroGrande = 1234567890L;</code>.</p> </li> <li> <p>Por defecto, un n\u00famero con decimales es de tipo <code>double</code>. Ejemplo: <code>3.14159</code>.</p> </li> </ul>"},{"location":"temas/02/index.html#235-valores-por-defecto","title":"2.3.5. Valores por Defecto","text":"<p>Si se declara una variable pero no se le asigna un valor inicial, Java le asigna uno por defecto:</p> <ul> <li> <p>Tipos num\u00e9ricos: <code>0</code>.</p> </li> <li> <p>Tipo boolean: <code>false</code>.</p> </li> <li> <p>Tipo char: valor nulo (<code>null</code>).</p> </li> <li> <p>Tipos de objeto (como <code>String</code>): <code>null</code>.</p> </li> </ul>"},{"location":"temas/02/index.html#236-ambito-de-las-variables","title":"2.3.6. \u00c1mbito de las Variables","text":"<p>El \u00e1mbito se refiere al bloque de c\u00f3digo en el que una variable es accesible y puede ser utilizada. La regla general es que una variable solo existe desde el punto donde se declara hasta el final de su bloque.</p> <ul> <li> <p>Variables globales: Se declaran al inicio del programa, perduran durante toda su ejecuci\u00f3n y pueden ser usadas desde cualquier parte del mismo.</p> </li> <li> <p>Variables locales: Se declaran dentro de un bloque espec\u00edfico y solo existen y pueden ser utilizadas dentro de ese bloque.</p> </li> </ul> <p>Ejemplo de \u00e1mbito:</p> <pre><code>public class EjemploAmbito {\n    static int variableGlobal = 10; // Variable global (de clase)\n\n    public static void miMetodo() {\n        int variableLocal = 20; // Variable local al m\u00e9todo\n        System.out.println(variableGlobal); // V\u00e1lido: Se puede acceder a la global\n        System.out.println(variableLocal); // V\u00e1lido: Se puede acceder a la local\n    }\n\n    public static void main(String[] args) {\n        miMetodo();\n        System.out.println(variableGlobal); // V\u00e1lido\n        // System.out.println(variableLocal); // ERROR: No se puede acceder a variableLocal aqu\u00ed\n    }\n}\n</code></pre>"},{"location":"temas/02/index.html#24-conversion-de-tipos-casting","title":"2.4. Conversi\u00f3n de Tipos (Casting)","text":"<p>Generalmente, es posible convertir un valor de un tipo a otro, siempre que la conversi\u00f3n sea l\u00f3gica.</p> <ul> <li> <p>Conversi\u00f3n impl\u00edcita: Java la realiza autom\u00e1ticamente cuando la conversi\u00f3n es trivial.</p> </li> <li> <p>Conversi\u00f3n expl\u00edcita (casting): Se debe forzar cuando puede haber p\u00e9rdida de informaci\u00f3n, indicando el nuevo tipo entre par\u00e9ntesis. Solo funciona entre tipos compatibles.</p> </li> </ul> <pre><code>double precio = 99.99;\nint precioEntero = (int) precio; // Casting expl\u00edcito, precioEntero ahora es 99\n</code></pre>"},{"location":"temas/02/index.html#25-constantes","title":"2.5. Constantes","text":"<p>Una constante es una variable cuyo valor no puede ser modificado una vez asignado. Se usan para definir valores fijos, evitando el uso de \"n\u00fameros m\u00e1gicos\" y facilitando su mantenimiento. La convenci\u00f3n para nombrarlas es usar may\u00fasculas y guiones bajos.</p> <p>Ejemplo de declaraci\u00f3n de constante:</p> <pre><code>// La palabra clave 'final' convierte una variable en constante.\nfinal int DIAS_SEMANA = 7;\nfinal double IVA_GENERAL = 0.21;\n</code></pre>"},{"location":"temas/02/index.html#26-convenciones-de-nombres-camelcase","title":"2.6. Convenciones de Nombres (CamelCase)","text":"<p>Java utiliza la convenci\u00f3n CamelCase para nombrar identificadores:</p> <ul> <li> <p>Clases: La primera letra de cada palabra va en may\u00fascula (<code>UpperCamelCase</code>). Ejemplos: <code>App</code>, <code>LectorArchivos</code>, <code>InterfazGrafica</code>.</p> </li> <li> <p>M\u00e9todos y Variables: La primera letra de la primera palabra va en min\u00fascula, y la primera de las siguientes en may\u00fascula (<code>lowerCamelCase</code>).</p> </li> </ul> <p>\u25e6 M\u00e9todos: <code>sumarNumeros()</code>, <code>importarTexto()</code>.</p> <p>\u25e6 Variables: <code>radio</code>, <code>resultadoSuma</code>.</p>"},{"location":"temas/02/index.html#27-operaciones-basicas","title":"2.7. Operaciones B\u00e1sicas","text":"<p>Java soporta varios tipos de operadores para realizar c\u00e1lculos y comparaciones:</p> <ul> <li> <p>Operaciones aritm\u00e9ticas.</p> </li> <li> <p>Operaciones relacionales.</p> </li> <li> <p>Operaciones l\u00f3gicas.</p> </li> <li> <p>Operaciones de asignaci\u00f3n.</p> </li> </ul>"},{"location":"temas/02/index.html#28-clases-fundamentales-de-la-api-de-java","title":"2.8. Clases Fundamentales de la API de Java","text":"<p>La API de Java proporciona clases \u00fatiles para tareas comunes.</p>"},{"location":"temas/02/index.html#281-clase-scanner","title":"2.8.1. Clase Scanner","text":"<p>Permite leer datos introducidos por el usuario a trav\u00e9s de la consola, por ejemplo, para almacenarlos en una variable.</p> <p>Ejemplo de uso:</p> <pre><code>import java.util.Scanner; // Es necesario importarla\n\npublic class LeerEntrada {\n    public static void main(String[] args) {\n        Scanner teclado = new Scanner(System.in);\n        System.out.print(\"Introduce tu edad: \");\n        int edad = teclado.nextInt();\n        System.out.println(\"Tu edad es: \" + edad);\n        teclado.close();\n    }\n}\n</code></pre>"},{"location":"temas/02/index.html#282-clase-random","title":"2.8.2. Clase Random","text":"<p>Facilita la generaci\u00f3n de n\u00fameros pseudoaleatorios de forma m\u00e1s vers\u00e1til que <code>Math.random()</code>, permitiendo crear enteros, booleanos o n\u00fameros dentro de un rango.</p> <p>Ejemplo de uso:</p> <pre><code>import java.util.Random; // Es necesario importarla\n\npublic class GenerarAleatorio {\n    public static void main(String[] args) {\n        Random generador = new Random();\n        int numeroAleatorio = generador.nextInt(10); // Genera un entero entre 0 y 9\n        System.out.println(\"N\u00famero aleatorio: \" + numeroAleatorio);\n    }\n}\n</code></pre>"},{"location":"temas/02/index.html#283-clase-math","title":"2.8.3. Clase Math","text":"<p>Proporciona m\u00e9todos est\u00e1ticos para operaciones matem\u00e1ticas comunes, como ra\u00edces cuadradas, potencias, redondeos, etc..</p> <p>Ejemplo de uso:</p> <pre><code>public class OperacionesMath {\n    public static void main(String[] args) {\n        double raizCuadrada = Math.sqrt(16.0); // raizCuadrada es 4.0\n        double potencia = Math.pow(2, 3); // potencia es 8.0 (2 elevado a 3)\n        System.out.println(\"La ra\u00edz cuadrada de 16 es \" + raizCuadrada);\n        System.out.println(\"2 elevado a 3 es \" + potencia);\n    }\n}\n</code></pre>"},{"location":"temas/02/index.html#29-sentencias-basicas","title":"2.9. Sentencias B\u00e1sicas","text":"<p>Adem\u00e1s de los elementos anteriores, la programaci\u00f3n en Java se estructura a trav\u00e9s de sentencias b\u00e1sicas que definen el flujo y las acciones del programa</p>"},{"location":"temas/03/index.html","title":"UT3. Estructuras de control","text":""},{"location":"temas/03/index.html#ut3-estructuras-de-control","title":"UT3. Estructuras de control","text":"<p>En este tema vamos a ver los conceptos b\u00e1sicos de la programaci\u00f3n estructurada y modular. Estos conceptos son fundamentales para entender c\u00f3mo se programan los ordenadores y c\u00f3mo se pueden resolver problemas de forma eficiente y clara.</p> <p>Son los primeros paradigmas de programaci\u00f3n que debemos aprender y dominar, ya que son la base para entender otros paradigmas m\u00e1s avanzados como la programaci\u00f3n orientada a objetos o la programaci\u00f3n funcional. Con ello vamos a dotar de comportamiento imperativo, es decir, vamos a indicarle al ordenador qu\u00e9 hacer y c\u00f3mo hacerlo, paso a paso y darle vida a nuestros algoritmos.</p>"},{"location":"temas/03/index.html#3-programacion-estructurada","title":"\ud83e\uddee 3. Programaci\u00f3n Estructurada","text":"<p>La programaci\u00f3n estructurada es un paradigma que busca crear programas m\u00e1s claros y f\u00e1ciles de mantener. Se basa en el Teorema de la programaci\u00f3n estructurada, que demuestra que cualquier algoritmo puede ser implementado utilizando \u00fanicamente tres estructuras de control b\u00e1sicas:</p> <ol> <li>Secuencia: Las instrucciones se ejecutan una despu\u00e9s de la otra, en el orden en que est\u00e1n escritas.</li> <li>Condicional (o Selecci\u00f3n): Se ejecuta un bloque de c\u00f3digo u otro dependiendo de si se cumple o no una condici\u00f3n.</li> <li>Bucle (o Iteraci\u00f3n): Un bloque de c\u00f3digo se repite mientras se cumpla una determinada condici\u00f3n.</li> </ol> <p></p>"},{"location":"temas/03/index.html#31-secuencias","title":"3.1. Secuencias","text":"<p>Es la estructura m\u00e1s simple. El programa ejecuta las instrucciones de arriba hacia abajo, una por una. Es la forma m\u00e1s b\u00e1sica de controlar el flujo de un programa, una instrucci\u00f3n tras otra.</p> <pre><code>Main {\n    // Ejemplo de Secuencia\n    writeLine(\"Hola\");\n    writeLine(\"\u00bfC\u00f3mo est\u00e1s?\");\n\n    // Leemos el nombre del usuario\n    writeLine(\"Por favor, introduce tu nombre:\");\n    string nombre = readLine();\n\n    // Mostramos un saludo personalizado\n    writeLine(\"Encantado de conocerte, \" + nombre);\n}\n</code></pre>"},{"location":"temas/03/index.html#32-condicionales-o-estructuras-de-seleccion","title":"3.2. Condicionales o Estructuras de selecci\u00f3n","text":"<p>Permiten que nuestro programa tome decisiones y se comporte de manera diferente seg\u00fan las circunstancias.</p> <p>Importante</p> <p>Las estructuras de selecci\u00f3n permiten tomar decisiones sobre qu\u00e9 conjunto de instrucciones a ejecutar en un punto del programa. O sea, seleccionar qu\u00e9 c\u00f3digo se ejecuta en un momento determinado entre caminos alternativos.</p> Tipos de estructuras de selecci\u00f3n <p>Condicional simple (<code>if</code>)</p> <p></p> <p>La estructura de selecci\u00f3n simple permite controlar el hecho de que se ejecute un conjunto de instrucciones si y s\u00f3lo si se cumple la condici\u00f3n l\u00f3gica (es decir, el resultado de evaluar la condici\u00f3n l\u00f3gica es igual a true). En caso contrario, no se ejecutan.</p> <pre><code>Main {\n    // Condicional simple\n    var edad = 20;\n    if (edad &gt;= 18) {\n        writeLine(\"Eres mayor de edad.\");\n    }\n}\n</code></pre> <p></p> <p>Condicional compuesto (<code>if-else</code>)</p> <p></p> <p>Permite ejecutar un bloque de c\u00f3digo si se cumple una condici\u00f3n y otro bloque si no se cumple.</p> <p></p><pre><code>Main {\n    // Condicional compuesto\n    var edad = 16;\n    if (edad &gt;= 18) {\n        writeLine(\"Eres mayor de edad.\");\n    } else {\n        writeLine(\"Eres menor de edad.\");\n    }\n}\n</code></pre> <p></p> <p>Condicionales m\u00faltiples (<code>if-else if-else</code>)</p> <p></p> <p>Permiten encadenar varias condiciones. El programa eval\u00faa las condiciones en orden y ejecuta el bloque de la primera que sea verdadera. Si ninguna lo es, se ejecuta el bloque <code>else</code> final (si existe).</p> <pre><code>Main {\n    // Condicionales m\u00faltiples\n    var edadAlumno = 16;\n    if (edadAlumno &gt;= 18) {\n        writeLine(\"Eres mayor de edad.\");\n    } else if (edadAlumno &gt;= 16) {\n        writeLine(\"Casi eres mayor de edad.\");\n    } else {\n        writeLine(\"Eres menor de edad.\");\n    }\n}\n</code></pre> <p></p> Ejemplo de Selecci\u00f3n m\u00faltiple <p>Estructura <code>switch</code></p> <p>Cuando necesitamos comparar una \u00fanica variable contra m\u00faltiples valores posibles, usar una cadena larga de <code>if-else if</code> puede ser engorroso y poco legible (efecto \"cascada\"). La estructura <code>switch</code> (o <code>seg\u00fan</code> en pseudoc\u00f3digo) ofrece una alternativa mucho m\u00e1s limpia y organizada. Eval\u00faa una expresi\u00f3n y ejecuta el bloque de c\u00f3digo (<code>case</code>) que coincida con el valor. Es obligatorio incluir una secci\u00f3n <code>default</code> para manejar los casos en que ninguno de los valores coincide.</p> <p></p> <pre><code>Main {\n    // Ejemplo de switch para los d\u00edas de la semana\n    var dia = 3; // Suponemos que 1 es Lunes, 2 es Martes, etc.\n    string nombreDelDia;\n\n    switch (dia) {\n        case 1:\n            nombreDelDia = \"Lunes\";\n            break; // 'break' es crucial para salir del switch\n        case 2:\n            nombreDelDia = \"Martes\";\n            break;\n        case 3:\n            nombreDelDia = \"Mi\u00e9rcoles\";\n            break;\n        case 4:\n            nombreDelDia = \"Jueves\";\n            break;\n        case 5:\n            nombreDelDia = \"Viernes\";\n            break;\n        case 6:\n        case 7:\n            nombreDelDia = \"Fin de semana\";\n            break; // Se pueden agrupar casos\n        default:\n            nombreDelDia = \"D\u00eda inv\u00e1lido\";\n            break;\n    }\n    writeLine(\"Hoy es: \" + nombreDelDia); // Imprimir\u00e1 \"Hoy es: Mi\u00e9rcoles\"\n}\n</code></pre> <p>Una de las t\u00e9cnicas m\u00e1s \u00fatiles para evitar errores comunes en los condicionales es el uso de par\u00e9ntesis para agrupar condiciones complejas. Esto mejora la legibilidad y asegura que las condiciones se eval\u00faan en el orden correcto.</p> <p></p><pre><code>Main {\n    var edad = 20;\n    var tieneDNI = true;\n    // Uso de par\u00e9ntesis para mayor claridad\n    if ((edad &gt;= 18) &amp;&amp; (tieneDNI)) {\n        writeLine(\"Puedes votar.\");\n    } else {\n        writeLine(\"No puedes votar.\");\n    }\n}\n</code></pre> <p></p>"},{"location":"temas/03/index.html#33-estructuras-de-repeticion-o-bucles","title":"3.3. Estructuras de repetici\u00f3n o Bucles","text":"<p>Los bucles nos permiten repetir un bloque de c\u00f3digo varias veces, ahorr\u00e1ndonos escribir la misma l\u00f3gica una y otra vez.</p> Estructuras de repetici\u00f3n <p>3.3.1 Bucles indefinidos (<code>while</code> y <code>do-while</code>):</p> <p>Se ejecutan mientras se cumpla una condici\u00f3n. Son \u00fatiles cuando no sabemos cu\u00e1ntas iteraciones se necesitar\u00e1n. <code>while</code> eval\u00faa la condici\u00f3n antes de cada iteraci\u00f3n, mientras que <code>do-while</code> la eval\u00faa despu\u00e9s, garantizando al menos una ejecuci\u00f3n. Esto es muy \u00fatil para men\u00fas o entradas de usuario.</p>"},{"location":"temas/03/index.html#bucle-while","title":"Bucle While","text":"<p>La sentencia while permite repetir la ejecuci\u00f3n del bucle mientras se verifique la condici\u00f3n l\u00f3gica. Esta verificaci\u00f3n se produce antes de entrar, al principio de cada iteraci\u00f3n. Si la primera vez, justo cuando se ejecuta la sentencia por primera vez, ya no se cumple, no se ejecuta ninguna iteraci\u00f3n.</p> <p></p> <pre><code>Main {\n    // Ejemplo de bucle while\n    var contador = 0;\n    while (contador &lt; 5) {\n        writeLine(\"Contador: \" + contador);\n        contador = contador + 1; // Incrementamos el contador\n    }\n    // Ejemplo de bucle do-while\n    var opcion;\n    do {\n        writeLine(\"Men\u00fa:\");\n        writeLine(\"1. Opci\u00f3n 1\");\n        writeLine(\"2. Opci\u00f3n 2\");\n        writeLine(\"3. Salir\");\n        opcion = readLine();\n        writeLine(\"Has seleccionado la opci\u00f3n: \" + opcion);\n    } while (opcion != \"3\");\n}\n</code></pre> <p>Control del Bucle</p> <p>Un bucle infinito es una secuencia de instrucciones dentro de un programa que itera indefinidamente, normalmente porque se espera que se alcance una condici\u00f3n que nunca se llega a producir.</p> <p>Importante</p> <p>Forzosamente dentro de todo bucle debe haber instrucciones que manipulen el valor de lagunas variables que nos permitan controlar la repetici\u00f3n o el final del cuble. Estas variables se conocen como variables de control.</p> <p></p> <p>Ejemplos de cada tipo:</p> <ul> <li> <p> </p><p>Contador</p><p></p> </li> <li> <p> </p><p>Acumulador</p><p></p> </li> <li> <p> </p><p>Sem\u00e1foro</p><p></p> </li> </ul> <p> </p>"},{"location":"temas/03/index.html#bucle-do-while","title":"Bucle do-While","text":"<p>La sentencia do-while permite repetir la ejecuci\u00f3n del bucle mientras se verifique la condici\u00f3n l\u00f3gica. Esta verificaci\u00f3n se produce antes de entrar, al principio de cada iteraci\u00f3n. Si la primera vez, justo cuando se ejecuta la sentencia por primera vez, ya no se cumple, no se ejecuta ninguna iteraci\u00f3n.</p> <p></p> <pre><code>Main {\n    // Ejemplo de bucle while\n    var contador = 0;\n    while (contador &lt; 5) {\n        writeLine(\"Contador: \" + contador);\n        contador = contador + 1; // Incrementamos el contador\n    }\n    // Ejemplo de bucle do-while\n    var opcion;\n    do {\n        writeLine(\"Men\u00fa:\");\n        writeLine(\"1. Opci\u00f3n 1\");\n        writeLine(\"2. Opci\u00f3n 2\");\n        writeLine(\"3. Salir\");\n        opcion = readLine();\n        writeLine(\"Has seleccionado la opci\u00f3n: \" + opcion);\n    } while (opcion != \"3\");\n}\n</code></pre>"},{"location":"temas/03/index.html#bucle-definidos-for","title":"Bucle definidos FOR","text":"<p>Los bucles definidos se utilizan cuando sabemos de antemano cu\u00e1ntas veces queremos repetir un bloque de c\u00f3digo. La estructura <code>for</code> incluye la inicializaci\u00f3n, la condici\u00f3n y el incremento/decremento en una sola l\u00ednea, lo que facilita su lectura y escritura. A continuaci\u00f3n se muestran varios ejemplos para dominar su funcionamiento.</p> <p></p> <pre><code>Main {\n    // 1. Bucle 'for' ascendente de 1 en 1\n    writeLine(\"Contando hacia adelante de 1 en 1:\");\n    for (int i = 0; i &lt;= 5; i = i + 1) {\n        writeLine(i); // Imprime 0, 1, 2, 3, 4, 5\n    }\n\n    // 2. Bucle 'for' descendente de 1 en 1\n    writeLine(\"Contando hacia atr\u00e1s de 1 en 1:\");\n    for (int i = 5; i &gt;= 0; i = i - 1) {\n        writeLine(i); // Imprime 5, 4, 3, 2, 1, 0\n    }\n\n    // 3. Bucle 'for' con saltos positivos (de 2 en 2)\n    writeLine(\"Contando hacia adelante de 2 en 2:\");\n    for (int i = 0; i &lt;= 10; i = i + 2) {\n        writeLine(i); // Imprime 0, 2, 4, 6, 8, 10\n    }\n\n    // 4. Bucle 'for' con saltos negativos (de 3 en 3)\n    writeLine(\"Contando hacia atr\u00e1s de 3 en 3:\");\n    for (int i = 15; i &gt;= 0; i = i - 3) {\n        writeLine(i); // Imprime 15, 12, 9, 6, 3, 0\n    }\n}\n</code></pre>"},{"location":"temas/03/index.html#34-mecanismos-de-control-de-bucles","title":"3.4. Mecanismos de Control de Bucles","text":"<p>Existen tres formas t\u00edpicas de controlar cu\u00e1ndo se ejecuta un bucle: bucles con contador, bucles controlados por indicadores (banderas o flags), y bucles controlados por centinela.</p> <ul> <li> <p>A. Bucles controlados por Indicadores (Banderas o Flags) \ud83d\udcec</p> <p>Las banderas (flags) son variables que suelen ser de tipo l\u00f3gico (<code>bool</code>) y se utilizan para controlar la ejecuci\u00f3n de un bucle. Se inicializan antes del bucle y cambian de valor dentro del mismo cuando se cumple la condici\u00f3n de parada.</p> <p>Ejemplo 1: Estructura b\u00e1sica de una bandera dentro de <code>Main</code></p> <pre><code>Main {\n    // Declaraci\u00f3n de variables dentro del \u00e1mbito local de Main\n    bool continuar = true; \n\n    // Mientras la bandera 'continuar' sea verdadera\n    while (continuar) \n    {     \n        // Simulamos instrucciones\n        // ...\n\n        // Si se cumple una condici\u00f3n (ej. leer \u2018N\u2019 del usuario), cambiamos el indicador\n        if (condicionParaAcabar) \n        {         \n            continuar = false;     \n        }     \n        // ... \n    }\n}\n</code></pre> <p>Ejemplo 2: Determinar si un n\u00famero contiene solo cifras menores que cinco</p> <pre><code>Main {\n    // Declaraci\u00f3n de variables\n    bool menor; \n    int num;\n\n    writeLine(\"Introduce un n\u00famero:\"); // Salida\n    num = (int)readLine(); // Entrada que requiere casting\n\n    menor = true; // Inicializacion del indicador\n\n    // El bucle se mantiene mientras el indicador sea true Y el n\u00famero tenga cifras\n    while (menor &amp;&amp; (num &gt; 0)) \n    {     \n        // Utilizamos el operador m\u00f3dulo (%) para revisar la \u00faltima cifra\n        if (num % 10 &gt;= 5) \n        {         \n            menor = false; // Cambiamos la bandera a false\n        }     \n        num = num / 10; // Eliminamos la \u00faltima cifra (divisi\u00f3n entera)\n    } \n\n    if (menor) \n    {\n        writeLine(\"Todas las cifras son menores que 5\");\n    } \n    else \n    {\n        writeLine(\"Hay alguna cifra mayor o igual que 5\");\n    }\n}\n</code></pre> </li> <li> <p>B. Bucles controlados por Centinela</p> <p>Los bucles controlados por centinela utilizan un valor especial (el centinela) que indica la parada de la iteraci\u00f3n.</p> <p>Ejemplo: Sumar n\u00fameros hasta que se introduce 0 (centinela)</p> <pre><code>Main {\n    // Declaraci\u00f3n de variables\n    int suma = 0; \n    int num;\n\n    writeLine(\"Introduce n\u00fameros a sumar, 0 para acabar\"); // Salida\n    num = (int)readLine(); // Entrada que requiere casting\n\n    // El bucle while contin\u00faa mientras el n\u00famero introducido no sea el centinela (0)\n    while (num != 0) \n    {     \n        suma = suma + num; // Acumulaci\u00f3n\n\n        writeLine(\"Introduce n\u00fameros a sumar, 0 para acabar\"); \n        num = (int)readLine(); // Nueva entrada\n    } \n\n    writeLine(suma); // Salida del resultado final\n}\n</code></pre> </li> <li> <p>C. Bucles Anidados</p> <p>Los bucles se pueden anidar (un bucle dentro de otro). Esta t\u00e9cnica es especialmente \u00fatil para el manejo de matrices.</p> <p>Ejemplo: Generar una tabla de multiplicar (1 a 10) usando bucles <code>for</code> anidados</p> <pre><code>Main {\n    // Declaraci\u00f3n de variables de control del bucle (i, j)\n    int i, j; \n\n    // Bucle externo\n    for (i = 1; i &lt;= 10; i++) \n    {     \n        // Bucle interno\n        for (j = 1; j &lt;= 10; j++) \n        {         \n            // Usamos concatenaci\u00f3n (+) para mostrar el resultado\n            writeLine(i + \"*\" + j + \"=\" + (i * j)); \n        } \n    }\n}\n</code></pre> </li> </ul>"},{"location":"temas/03/index.html#4-estructuras-de-salto","title":"\u23ec 4. Estructuras de Salto","text":"<p>Las sentencias de salto son herramientas del lenguaje que proporcionan un control m\u00e1s preciso sobre el comportamiento de nuestros bucles, permiti\u00e9ndonos alterar su ejecuci\u00f3n normal bajo ciertas condiciones.</p> Estructuras de salto"},{"location":"temas/03/index.html#41-break-interrupcion-inmediata-del-bucle","title":"4.1 Break: Interrupci\u00f3n Inmediata del Bucle \ud83c\udfc1","text":"<p>La sentencia break tiene un prop\u00f3sito claro y contundente: terminar la ejecuci\u00f3n del bucle m\u00e1s interno en el que se encuentra. Una vez que el flujo del programa encuentra una instrucci\u00f3n break, el bucle se detiene inmediatamente y el control se transfiere a la siguiente instrucci\u00f3n despu\u00e9s del bucle.</p> <p>Es una herramienta poderosa para detener un proceso iterativo cuando se ha cumplido un objetivo espec\u00edfico, sin necesidad de completar todas las iteraciones restantes.</p> <p>Ejemplo 1: Encontrar el primer m\u00faltiplo de 7</p> <p>Imaginemos que queremos contar del 1 al 20, pero deseamos detenernos tan pronto como encontremos el primer n\u00famero que es divisible por 7.</p> <pre><code>public class EjemploBreakSencillo {\n    public static void main(String[] args) {\n        System.out.println(\"Buscando el primer m\u00faltiplo de 7 entre 1 y 20...\");\n\n        for (int i = 1; i &lt;= 20; i++) {\n            System.out.println(\"Probando el n\u00famero: \" + i);\n            if (i % 7 == 0) { // Si 'i' es divisible por 7\n                System.out.println(\"\u00a1Encontrado! El n\u00famero es: \" + i);\n                break; // Salimos del bucle inmediatamente\n            }\n        }\n\n        System.out.println(\"El bucle ha terminado.\");\n    }\n}\n</code></pre> <p>Salida del programa:</p> <pre><code>Buscando el primer m\u00faltiplo de 7 entre 1 y 20...\nProbando el n\u00famero: 1\nProbando el n\u00famero: 2\nProbando el n\u00famero: 3\nProbando el n\u00famero: 4\nProbando el n\u00famero: 5\nProbando el n\u00famero: 6\nProbando el n\u00famero: 7\n\u00a1Encontrado! El n\u00famero es: 7\nEl bucle ha terminado.\n</code></pre> <p>Ejemplo 2: Imprimir solo los n\u00fameros pares</p> <p>Supongamos que queremos imprimir los n\u00fameros del 1 al 10, pero queremos omitir todos los n\u00fameros pares.</p> <pre><code>public class EjemploContinueSencillo {\n    public static void main(String[] args) {\n        System.out.println(\"Imprimiendo solo los n\u00fameros impares del 1 al 10:\");\n\n        for (int i = 1; i &lt;= 10; i++) {\n            if (i % 2 == 0) { // Si el n\u00famero es par\n                continue; // Omitimos el resto de esta iteraci\u00f3n y vamos a la siguiente\n            }\n            // Esta l\u00ednea solo se ejecutar\u00e1 si el n\u00famero es impar\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <p>Salida del programa:</p> <p></p><pre><code>Imprimiendo solo los n\u00fameros impares del 1 al 10:\n1\n3\n5\n7\n9\n</code></pre> Aqu\u00ed, cada vez que i era un n\u00famero par, la sentencia continue se activaba, evitando que se ejecutara la l\u00ednea System.out.println(i) y forzando al bucle a comenzar la siguiente iteraci\u00f3n.<p></p> <p></p>"},{"location":"temas/03/index.html#42-continue-omitir-y-seguir-adelante","title":"4.2 Continue: Omitir y Seguir Adelante \u2196\ufe0f","text":"<p>A diferencia de break, la sentencia continue no detiene el bucle. Lo que hace es detener la iteraci\u00f3n actual y saltar directamente al inicio de la siguiente. Es como decir: \"No me interesa lo que queda por hacer en esta vuelta, pasemos a la siguiente\".</p> <p>Esto es muy \u00fatil para filtrar u omitir ciertos casos dentro de una secuencia sin necesidad de detener todo el proceso.</p> <p>Ejemplo 2: Imprimir solo los n\u00fameros impares</p> <pre><code>public class EjemploContinueSencillo {\n    public static void main(String[] args) {\n        System.out.println(\"Imprimiendo solo los n\u00fameros impares del 1 al 10:\");\n\n        for (int i = 1; i &lt;= 10; i++) {\n            if (i % 2 == 0) { // Si el n\u00famero es par\n                continue; // Omitimos el resto de esta iteraci\u00f3n y vamos a la siguiente\n            }\n            // Esta l\u00ednea solo se ejecutar\u00e1 si el n\u00famero es impar\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <p>Salida del programa:</p> <pre><code>Imprimiendo solo los n\u00fameros impares del 1 al 10:\n1\n3\n5\n7\n9\n</code></pre> <p>Aqu\u00ed, cada vez que i era un n\u00famero par, la sentencia continue se activaba, evitando que se ejecutara la l\u00ednea System.out.println(i) y forzando al bucle a comenzar la siguiente iteraci\u00f3n.</p>"},{"location":"temas/03/index.html#43-return-salida-definitiva-del-metodo","title":"4.3 return: Salida Definitiva del M\u00e9todo \u2b05\ufe0f","text":"<p>La sentencia return es la m\u00e1s dr\u00e1stica de las tres. No solo detiene el bucle, sino que termina la ejecuci\u00f3n de todo el m\u00e9todo en el que se encuentra. </p> <p>Cualquier c\u00f3digo que venga despu\u00e9s de la instrucci\u00f3n return, tanto dentro como fuera del bucle, no se ejecutar\u00e1. Generalmente se usa para devolver un valor desde un m\u00e9todo, pero tambi\u00e9n puede usarse en m\u00e9todos void (que no devuelven nada) para provocar una salida temprana.</p> <p>Ejemplo 1: Buscar un n\u00famero dentro de un m\u00e9todo</p> <p>Para ilustrar esto, crearemos un m\u00e9todo separado. Este m\u00e9todo buscar\u00e1 un \"c\u00f3digo de error\" espec\u00edfico en un rango de n\u00fameros. Si lo encuentra, informar\u00e1 de ello y saldr\u00e1 inmediatamente del m\u00e9todo.</p> <p></p><pre><code>public class EjemploReturnSencillo {\n\n    // Este m\u00e9todo busca un c\u00f3digo de error entre 1 y 100\n    public static void main(String[] args) {\n        int codigoError = 44;\n\n        System.out.println(\"Iniciando la verificaci\u00f3n de c\u00f3digos...\");\n\n        for (int i = 1; i &lt;= 100; i++) {\n            if (i == codigoError) {\n                System.out.println(\"\u00a1Alerta! C\u00f3digo de error \" + i + \" encontrado. Terminando ejecuci\u00f3n.\");\n                return; // Salimos del m\u00e9todo verificarCodigos() por completo\n            }\n        }\n\n        // Esta l\u00ednea NUNCA se ejecutar\u00e1 si se encuentra el c\u00f3digo de error\n        System.out.println(\"Verificaci\u00f3n completada sin encontrar el c\u00f3digo de error.\");\n    }\n}\n</code></pre> Salida del programa:<p></p> <pre><code>Iniciando la verificaci\u00f3n de c\u00f3digos...\n\u00a1Alerta! C\u00f3digo de error 44 encontrado. Terminando ejecuci\u00f3n.\nPrograma principal contin\u00faa...\n</code></pre>"},{"location":"temas/03/3.1-prog-estructurada.html","title":"3.1 - Prog. estructurada","text":""},{"location":"temas/03/3.1-prog-estructurada.html#ut3-estructuras-de-control","title":"UT3. Estructuras de control","text":"<p>En este tema vamos a ver los conceptos b\u00e1sicos de la programaci\u00f3n estructurada y modular. Estos conceptos son fundamentales para entender c\u00f3mo se programan los ordenadores y c\u00f3mo se pueden resolver problemas de forma eficiente y clara.</p> <p>Son los primeros paradigmas de programaci\u00f3n que debemos aprender y dominar, ya que son la base para entender otros paradigmas m\u00e1s avanzados como la programaci\u00f3n orientada a objetos o la programaci\u00f3n funcional. Con ello vamos a dotar de comportamiento imperativo, es decir, vamos a indicarle al ordenador qu\u00e9 hacer y c\u00f3mo hacerlo, paso a paso y darle vida a nuestros algoritmos.</p>"},{"location":"temas/03/3.1-prog-estructurada.html#3-programacion-estructurada","title":"\ud83e\uddee 3. Programaci\u00f3n Estructurada","text":"<p>La programaci\u00f3n estructurada es un paradigma que busca crear programas m\u00e1s claros y f\u00e1ciles de mantener. Se basa en el Teorema de la programaci\u00f3n estructurada, que demuestra que cualquier algoritmo puede ser implementado utilizando \u00fanicamente tres estructuras de control b\u00e1sicas:</p> <ol> <li>Secuencia: Las instrucciones se ejecutan una despu\u00e9s de la otra, en el orden en que est\u00e1n escritas.</li> <li>Condicional (o Selecci\u00f3n): Se ejecuta un bloque de c\u00f3digo u otro dependiendo de si se cumple o no una condici\u00f3n.</li> <li>Bucle (o Iteraci\u00f3n): Un bloque de c\u00f3digo se repite mientras se cumpla una determinada condici\u00f3n.</li> </ol> <p></p>"},{"location":"temas/03/3.1-prog-estructurada.html#31-secuencias","title":"3.1. Secuencias","text":"<p>Es la estructura m\u00e1s simple. El programa ejecuta las instrucciones de arriba hacia abajo, una por una. Es la forma m\u00e1s b\u00e1sica de controlar el flujo de un programa, una instrucci\u00f3n tras otra.</p> <pre><code>Main {\n    // Ejemplo de Secuencia\n    writeLine(\"Hola\");\n    writeLine(\"\u00bfC\u00f3mo est\u00e1s?\");\n\n    // Leemos el nombre del usuario\n    writeLine(\"Por favor, introduce tu nombre:\");\n    string nombre = readLine();\n\n    // Mostramos un saludo personalizado\n    writeLine(\"Encantado de conocerte, \" + nombre);\n}\n</code></pre>"},{"location":"temas/03/3.1-prog-estructurada.html#32-condicionales-o-estructuras-de-seleccion","title":"3.2. Condicionales o Estructuras de selecci\u00f3n","text":"<p>Permiten que nuestro programa tome decisiones y se comporte de manera diferente seg\u00fan las circunstancias.</p> <p>Importante</p> <p>Las estructuras de selecci\u00f3n permiten tomar decisiones sobre qu\u00e9 conjunto de instrucciones a ejecutar en un punto del programa. O sea, seleccionar qu\u00e9 c\u00f3digo se ejecuta en un momento determinado entre caminos alternativos.</p> Tipos de estructuras de selecci\u00f3n <p>Condicional simple (<code>if</code>)</p> <p></p> <p>La estructura de selecci\u00f3n simple permite controlar el hecho de que se ejecute un conjunto de instrucciones si y s\u00f3lo si se cumple la condici\u00f3n l\u00f3gica (es decir, el resultado de evaluar la condici\u00f3n l\u00f3gica es igual a true). En caso contrario, no se ejecutan.</p> <pre><code>Main {\n    // Condicional simple\n    var edad = 20;\n    if (edad &gt;= 18) {\n        writeLine(\"Eres mayor de edad.\");\n    }\n}\n</code></pre> <p></p> <p>Condicional compuesto (<code>if-else</code>)</p> <p></p> <p>Permite ejecutar un bloque de c\u00f3digo si se cumple una condici\u00f3n y otro bloque si no se cumple.</p> <p></p><pre><code>Main {\n    // Condicional compuesto\n    var edad = 16;\n    if (edad &gt;= 18) {\n        writeLine(\"Eres mayor de edad.\");\n    } else {\n        writeLine(\"Eres menor de edad.\");\n    }\n}\n</code></pre> <p></p> <p>Condicionales m\u00faltiples (<code>if-else if-else</code>)</p> <p></p> <p>Permiten encadenar varias condiciones. El programa eval\u00faa las condiciones en orden y ejecuta el bloque de la primera que sea verdadera. Si ninguna lo es, se ejecuta el bloque <code>else</code> final (si existe).</p> <pre><code>Main {\n    // Condicionales m\u00faltiples\n    var edadAlumno = 16;\n    if (edadAlumno &gt;= 18) {\n        writeLine(\"Eres mayor de edad.\");\n    } else if (edadAlumno &gt;= 16) {\n        writeLine(\"Casi eres mayor de edad.\");\n    } else {\n        writeLine(\"Eres menor de edad.\");\n    }\n}\n</code></pre> <p></p> Ejemplo de Selecci\u00f3n m\u00faltiple <p>Estructura <code>switch</code></p> <p>Cuando necesitamos comparar una \u00fanica variable contra m\u00faltiples valores posibles, usar una cadena larga de <code>if-else if</code> puede ser engorroso y poco legible (efecto \"cascada\"). La estructura <code>switch</code> (o <code>seg\u00fan</code> en pseudoc\u00f3digo) ofrece una alternativa mucho m\u00e1s limpia y organizada. Eval\u00faa una expresi\u00f3n y ejecuta el bloque de c\u00f3digo (<code>case</code>) que coincida con el valor. Es obligatorio incluir una secci\u00f3n <code>default</code> para manejar los casos en que ninguno de los valores coincide.</p> <p></p> <pre><code>Main {\n    // Ejemplo de switch para los d\u00edas de la semana\n    var dia = 3; // Suponemos que 1 es Lunes, 2 es Martes, etc.\n    string nombreDelDia;\n\n    switch (dia) {\n        case 1:\n            nombreDelDia = \"Lunes\";\n            break; // 'break' es crucial para salir del switch\n        case 2:\n            nombreDelDia = \"Martes\";\n            break;\n        case 3:\n            nombreDelDia = \"Mi\u00e9rcoles\";\n            break;\n        case 4:\n            nombreDelDia = \"Jueves\";\n            break;\n        case 5:\n            nombreDelDia = \"Viernes\";\n            break;\n        case 6:\n        case 7:\n            nombreDelDia = \"Fin de semana\";\n            break; // Se pueden agrupar casos\n        default:\n            nombreDelDia = \"D\u00eda inv\u00e1lido\";\n            break;\n    }\n    writeLine(\"Hoy es: \" + nombreDelDia); // Imprimir\u00e1 \"Hoy es: Mi\u00e9rcoles\"\n}\n</code></pre> <p>Una de las t\u00e9cnicas m\u00e1s \u00fatiles para evitar errores comunes en los condicionales es el uso de par\u00e9ntesis para agrupar condiciones complejas. Esto mejora la legibilidad y asegura que las condiciones se eval\u00faan en el orden correcto.</p> <p></p><pre><code>Main {\n    var edad = 20;\n    var tieneDNI = true;\n    // Uso de par\u00e9ntesis para mayor claridad\n    if ((edad &gt;= 18) &amp;&amp; (tieneDNI)) {\n        writeLine(\"Puedes votar.\");\n    } else {\n        writeLine(\"No puedes votar.\");\n    }\n}\n</code></pre> <p></p>"},{"location":"temas/03/3.1-prog-estructurada.html#33-estructuras-de-repeticion-o-bucles","title":"3.3. Estructuras de repetici\u00f3n o Bucles","text":"<p>Los bucles nos permiten repetir un bloque de c\u00f3digo varias veces, ahorr\u00e1ndonos escribir la misma l\u00f3gica una y otra vez.</p> Estructuras de repetici\u00f3n <p>3.3.1 Bucles indefinidos (<code>while</code> y <code>do-while</code>):</p> <p>Se ejecutan mientras se cumpla una condici\u00f3n. Son \u00fatiles cuando no sabemos cu\u00e1ntas iteraciones se necesitar\u00e1n. <code>while</code> eval\u00faa la condici\u00f3n antes de cada iteraci\u00f3n, mientras que <code>do-while</code> la eval\u00faa despu\u00e9s, garantizando al menos una ejecuci\u00f3n. Esto es muy \u00fatil para men\u00fas o entradas de usuario.</p>"},{"location":"temas/03/3.1-prog-estructurada.html#bucle-while","title":"Bucle While","text":"<p>La sentencia while permite repetir la ejecuci\u00f3n del bucle mientras se verifique la condici\u00f3n l\u00f3gica. Esta verificaci\u00f3n se produce antes de entrar, al principio de cada iteraci\u00f3n. Si la primera vez, justo cuando se ejecuta la sentencia por primera vez, ya no se cumple, no se ejecuta ninguna iteraci\u00f3n.</p> <p></p> <pre><code>Main {\n    // Ejemplo de bucle while\n    var contador = 0;\n    while (contador &lt; 5) {\n        writeLine(\"Contador: \" + contador);\n        contador = contador + 1; // Incrementamos el contador\n    }\n    // Ejemplo de bucle do-while\n    var opcion;\n    do {\n        writeLine(\"Men\u00fa:\");\n        writeLine(\"1. Opci\u00f3n 1\");\n        writeLine(\"2. Opci\u00f3n 2\");\n        writeLine(\"3. Salir\");\n        opcion = readLine();\n        writeLine(\"Has seleccionado la opci\u00f3n: \" + opcion);\n    } while (opcion != \"3\");\n}\n</code></pre> <p>Control del Bucle</p> <p>Un bucle infinito es una secuencia de instrucciones dentro de un programa que itera indefinidamente, normalmente porque se espera que se alcance una condici\u00f3n que nunca se llega a producir.</p> <p>Importante</p> <p>Forzosamente dentro de todo bucle debe haber instrucciones que manipulen el valor de lagunas variables que nos permitan controlar la repetici\u00f3n o el final del cuble. Estas variables se conocen como variables de control.</p> <p></p> <p>Ejemplos de cada tipo:</p> <ul> <li> <p> </p><p>Contador</p><p></p> </li> <li> <p> </p><p>Acumulador</p><p></p> </li> <li> <p> </p><p>Sem\u00e1foro</p><p></p> </li> </ul> <p> </p>"},{"location":"temas/03/3.1-prog-estructurada.html#bucle-do-while","title":"Bucle do-While","text":"<p>La sentencia do-while permite repetir la ejecuci\u00f3n del bucle mientras se verifique la condici\u00f3n l\u00f3gica. Esta verificaci\u00f3n se produce antes de entrar, al principio de cada iteraci\u00f3n. Si la primera vez, justo cuando se ejecuta la sentencia por primera vez, ya no se cumple, no se ejecuta ninguna iteraci\u00f3n.</p> <p></p> <pre><code>Main {\n    // Ejemplo de bucle while\n    var contador = 0;\n    while (contador &lt; 5) {\n        writeLine(\"Contador: \" + contador);\n        contador = contador + 1; // Incrementamos el contador\n    }\n    // Ejemplo de bucle do-while\n    var opcion;\n    do {\n        writeLine(\"Men\u00fa:\");\n        writeLine(\"1. Opci\u00f3n 1\");\n        writeLine(\"2. Opci\u00f3n 2\");\n        writeLine(\"3. Salir\");\n        opcion = readLine();\n        writeLine(\"Has seleccionado la opci\u00f3n: \" + opcion);\n    } while (opcion != \"3\");\n}\n</code></pre>"},{"location":"temas/03/3.1-prog-estructurada.html#bucle-definidos-for","title":"Bucle definidos FOR","text":"<p>Los bucles definidos se utilizan cuando sabemos de antemano cu\u00e1ntas veces queremos repetir un bloque de c\u00f3digo. La estructura <code>for</code> incluye la inicializaci\u00f3n, la condici\u00f3n y el incremento/decremento en una sola l\u00ednea, lo que facilita su lectura y escritura. A continuaci\u00f3n se muestran varios ejemplos para dominar su funcionamiento.</p> <p></p> <pre><code>Main {\n    // 1. Bucle 'for' ascendente de 1 en 1\n    writeLine(\"Contando hacia adelante de 1 en 1:\");\n    for (int i = 0; i &lt;= 5; i = i + 1) {\n        writeLine(i); // Imprime 0, 1, 2, 3, 4, 5\n    }\n\n    // 2. Bucle 'for' descendente de 1 en 1\n    writeLine(\"Contando hacia atr\u00e1s de 1 en 1:\");\n    for (int i = 5; i &gt;= 0; i = i - 1) {\n        writeLine(i); // Imprime 5, 4, 3, 2, 1, 0\n    }\n\n    // 3. Bucle 'for' con saltos positivos (de 2 en 2)\n    writeLine(\"Contando hacia adelante de 2 en 2:\");\n    for (int i = 0; i &lt;= 10; i = i + 2) {\n        writeLine(i); // Imprime 0, 2, 4, 6, 8, 10\n    }\n\n    // 4. Bucle 'for' con saltos negativos (de 3 en 3)\n    writeLine(\"Contando hacia atr\u00e1s de 3 en 3:\");\n    for (int i = 15; i &gt;= 0; i = i - 3) {\n        writeLine(i); // Imprime 15, 12, 9, 6, 3, 0\n    }\n}\n</code></pre>"},{"location":"temas/03/3.1-prog-estructurada.html#34-mecanismos-de-control-de-bucles","title":"3.4. Mecanismos de Control de Bucles","text":"<p>Existen tres formas t\u00edpicas de controlar cu\u00e1ndo se ejecuta un bucle: bucles con contador, bucles controlados por indicadores (banderas o flags), y bucles controlados por centinela.</p> <ul> <li> <p>A. Bucles controlados por Indicadores (Banderas o Flags) \ud83d\udcec</p> <p>Las banderas (flags) son variables que suelen ser de tipo l\u00f3gico (<code>bool</code>) y se utilizan para controlar la ejecuci\u00f3n de un bucle. Se inicializan antes del bucle y cambian de valor dentro del mismo cuando se cumple la condici\u00f3n de parada.</p> <p>Ejemplo 1: Estructura b\u00e1sica de una bandera dentro de <code>Main</code></p> <pre><code>Main {\n    // Declaraci\u00f3n de variables dentro del \u00e1mbito local de Main\n    bool continuar = true; \n\n    // Mientras la bandera 'continuar' sea verdadera\n    while (continuar) \n    {     \n        // Simulamos instrucciones\n        // ...\n\n        // Si se cumple una condici\u00f3n (ej. leer \u2018N\u2019 del usuario), cambiamos el indicador\n        if (condicionParaAcabar) \n        {         \n            continuar = false;     \n        }     \n        // ... \n    }\n}\n</code></pre> <p>Ejemplo 2: Determinar si un n\u00famero contiene solo cifras menores que cinco</p> <pre><code>Main {\n    // Declaraci\u00f3n de variables\n    bool menor; \n    int num;\n\n    writeLine(\"Introduce un n\u00famero:\"); // Salida\n    num = (int)readLine(); // Entrada que requiere casting\n\n    menor = true; // Inicializacion del indicador\n\n    // El bucle se mantiene mientras el indicador sea true Y el n\u00famero tenga cifras\n    while (menor &amp;&amp; (num &gt; 0)) \n    {     \n        // Utilizamos el operador m\u00f3dulo (%) para revisar la \u00faltima cifra\n        if (num % 10 &gt;= 5) \n        {         \n            menor = false; // Cambiamos la bandera a false\n        }     \n        num = num / 10; // Eliminamos la \u00faltima cifra (divisi\u00f3n entera)\n    } \n\n    if (menor) \n    {\n        writeLine(\"Todas las cifras son menores que 5\");\n    } \n    else \n    {\n        writeLine(\"Hay alguna cifra mayor o igual que 5\");\n    }\n}\n</code></pre> </li> <li> <p>B. Bucles controlados por Centinela</p> <p>Los bucles controlados por centinela utilizan un valor especial (el centinela) que indica la parada de la iteraci\u00f3n.</p> <p>Ejemplo: Sumar n\u00fameros hasta que se introduce 0 (centinela)</p> <pre><code>Main {\n    // Declaraci\u00f3n de variables\n    int suma = 0; \n    int num;\n\n    writeLine(\"Introduce n\u00fameros a sumar, 0 para acabar\"); // Salida\n    num = (int)readLine(); // Entrada que requiere casting\n\n    // El bucle while contin\u00faa mientras el n\u00famero introducido no sea el centinela (0)\n    while (num != 0) \n    {     \n        suma = suma + num; // Acumulaci\u00f3n\n\n        writeLine(\"Introduce n\u00fameros a sumar, 0 para acabar\"); \n        num = (int)readLine(); // Nueva entrada\n    } \n\n    writeLine(suma); // Salida del resultado final\n}\n</code></pre> </li> <li> <p>C. Bucles Anidados</p> <p>Los bucles se pueden anidar (un bucle dentro de otro). Esta t\u00e9cnica es especialmente \u00fatil para el manejo de matrices.</p> <p>Ejemplo: Generar una tabla de multiplicar (1 a 10) usando bucles <code>for</code> anidados</p> <pre><code>Main {\n    // Declaraci\u00f3n de variables de control del bucle (i, j)\n    int i, j; \n\n    // Bucle externo\n    for (i = 1; i &lt;= 10; i++) \n    {     \n        // Bucle interno\n        for (j = 1; j &lt;= 10; j++) \n        {         \n            // Usamos concatenaci\u00f3n (+) para mostrar el resultado\n            writeLine(i + \"*\" + j + \"=\" + (i * j)); \n        } \n    }\n}\n</code></pre> </li> </ul>"},{"location":"temas/03/3.1-prog-estructurada.html#4-estructuras-de-salto","title":"\u23ec 4. Estructuras de Salto","text":"<p>Las sentencias de salto son herramientas del lenguaje que proporcionan un control m\u00e1s preciso sobre el comportamiento de nuestros bucles, permiti\u00e9ndonos alterar su ejecuci\u00f3n normal bajo ciertas condiciones.</p> Estructuras de salto"},{"location":"temas/03/3.1-prog-estructurada.html#41-break-interrupcion-inmediata-del-bucle","title":"4.1 Break: Interrupci\u00f3n Inmediata del Bucle \ud83c\udfc1","text":"<p>La sentencia break tiene un prop\u00f3sito claro y contundente: terminar la ejecuci\u00f3n del bucle m\u00e1s interno en el que se encuentra. Una vez que el flujo del programa encuentra una instrucci\u00f3n break, el bucle se detiene inmediatamente y el control se transfiere a la siguiente instrucci\u00f3n despu\u00e9s del bucle.</p> <p>Es una herramienta poderosa para detener un proceso iterativo cuando se ha cumplido un objetivo espec\u00edfico, sin necesidad de completar todas las iteraciones restantes.</p> <p>Ejemplo 1: Encontrar el primer m\u00faltiplo de 7</p> <p>Imaginemos que queremos contar del 1 al 20, pero deseamos detenernos tan pronto como encontremos el primer n\u00famero que es divisible por 7.</p> <pre><code>public class EjemploBreakSencillo {\n    public static void main(String[] args) {\n        System.out.println(\"Buscando el primer m\u00faltiplo de 7 entre 1 y 20...\");\n\n        for (int i = 1; i &lt;= 20; i++) {\n            System.out.println(\"Probando el n\u00famero: \" + i);\n            if (i % 7 == 0) { // Si 'i' es divisible por 7\n                System.out.println(\"\u00a1Encontrado! El n\u00famero es: \" + i);\n                break; // Salimos del bucle inmediatamente\n            }\n        }\n\n        System.out.println(\"El bucle ha terminado.\");\n    }\n}\n</code></pre> <p>Salida del programa:</p> <pre><code>Buscando el primer m\u00faltiplo de 7 entre 1 y 20...\nProbando el n\u00famero: 1\nProbando el n\u00famero: 2\nProbando el n\u00famero: 3\nProbando el n\u00famero: 4\nProbando el n\u00famero: 5\nProbando el n\u00famero: 6\nProbando el n\u00famero: 7\n\u00a1Encontrado! El n\u00famero es: 7\nEl bucle ha terminado.\n</code></pre> <p>Ejemplo 2: Imprimir solo los n\u00fameros pares</p> <p>Supongamos que queremos imprimir los n\u00fameros del 1 al 10, pero queremos omitir todos los n\u00fameros pares.</p> <pre><code>public class EjemploContinueSencillo {\n    public static void main(String[] args) {\n        System.out.println(\"Imprimiendo solo los n\u00fameros impares del 1 al 10:\");\n\n        for (int i = 1; i &lt;= 10; i++) {\n            if (i % 2 == 0) { // Si el n\u00famero es par\n                continue; // Omitimos el resto de esta iteraci\u00f3n y vamos a la siguiente\n            }\n            // Esta l\u00ednea solo se ejecutar\u00e1 si el n\u00famero es impar\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <p>Salida del programa:</p> <p></p><pre><code>Imprimiendo solo los n\u00fameros impares del 1 al 10:\n1\n3\n5\n7\n9\n</code></pre> Aqu\u00ed, cada vez que i era un n\u00famero par, la sentencia continue se activaba, evitando que se ejecutara la l\u00ednea System.out.println(i) y forzando al bucle a comenzar la siguiente iteraci\u00f3n.<p></p> <p></p>"},{"location":"temas/03/3.1-prog-estructurada.html#42-continue-omitir-y-seguir-adelante","title":"4.2 Continue: Omitir y Seguir Adelante \u2196\ufe0f","text":"<p>A diferencia de break, la sentencia continue no detiene el bucle. Lo que hace es detener la iteraci\u00f3n actual y saltar directamente al inicio de la siguiente. Es como decir: \"No me interesa lo que queda por hacer en esta vuelta, pasemos a la siguiente\".</p> <p>Esto es muy \u00fatil para filtrar u omitir ciertos casos dentro de una secuencia sin necesidad de detener todo el proceso.</p> <p>Ejemplo 2: Imprimir solo los n\u00fameros impares</p> <pre><code>public class EjemploContinueSencillo {\n    public static void main(String[] args) {\n        System.out.println(\"Imprimiendo solo los n\u00fameros impares del 1 al 10:\");\n\n        for (int i = 1; i &lt;= 10; i++) {\n            if (i % 2 == 0) { // Si el n\u00famero es par\n                continue; // Omitimos el resto de esta iteraci\u00f3n y vamos a la siguiente\n            }\n            // Esta l\u00ednea solo se ejecutar\u00e1 si el n\u00famero es impar\n            System.out.println(i);\n        }\n    }\n}\n</code></pre> <p>Salida del programa:</p> <pre><code>Imprimiendo solo los n\u00fameros impares del 1 al 10:\n1\n3\n5\n7\n9\n</code></pre> <p>Aqu\u00ed, cada vez que i era un n\u00famero par, la sentencia continue se activaba, evitando que se ejecutara la l\u00ednea System.out.println(i) y forzando al bucle a comenzar la siguiente iteraci\u00f3n.</p>"},{"location":"temas/03/3.1-prog-estructurada.html#43-return-salida-definitiva-del-metodo","title":"4.3 return: Salida Definitiva del M\u00e9todo \u2b05\ufe0f","text":"<p>La sentencia return es la m\u00e1s dr\u00e1stica de las tres. No solo detiene el bucle, sino que termina la ejecuci\u00f3n de todo el m\u00e9todo en el que se encuentra. </p> <p>Cualquier c\u00f3digo que venga despu\u00e9s de la instrucci\u00f3n return, tanto dentro como fuera del bucle, no se ejecutar\u00e1. Generalmente se usa para devolver un valor desde un m\u00e9todo, pero tambi\u00e9n puede usarse en m\u00e9todos void (que no devuelven nada) para provocar una salida temprana.</p> <p>Ejemplo 1: Buscar un n\u00famero dentro de un m\u00e9todo</p> <p>Para ilustrar esto, crearemos un m\u00e9todo separado. Este m\u00e9todo buscar\u00e1 un \"c\u00f3digo de error\" espec\u00edfico en un rango de n\u00fameros. Si lo encuentra, informar\u00e1 de ello y saldr\u00e1 inmediatamente del m\u00e9todo.</p> <p></p><pre><code>public class EjemploReturnSencillo {\n\n    // Este m\u00e9todo busca un c\u00f3digo de error entre 1 y 100\n    public static void main(String[] args) {\n        int codigoError = 44;\n\n        System.out.println(\"Iniciando la verificaci\u00f3n de c\u00f3digos...\");\n\n        for (int i = 1; i &lt;= 100; i++) {\n            if (i == codigoError) {\n                System.out.println(\"\u00a1Alerta! C\u00f3digo de error \" + i + \" encontrado. Terminando ejecuci\u00f3n.\");\n                return; // Salimos del m\u00e9todo verificarCodigos() por completo\n            }\n        }\n\n        // Esta l\u00ednea NUNCA se ejecutar\u00e1 si se encuentra el c\u00f3digo de error\n        System.out.println(\"Verificaci\u00f3n completada sin encontrar el c\u00f3digo de error.\");\n    }\n}\n</code></pre> Salida del programa:<p></p> <pre><code>Iniciando la verificaci\u00f3n de c\u00f3digos...\n\u00a1Alerta! C\u00f3digo de error 44 encontrado. Terminando ejecuci\u00f3n.\nPrograma principal contin\u00faa...\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html","title":"UT3.2 Programaci\u00f3n modular","text":""},{"location":"temas/03/3.2-prog-modular.html#ut32-programacion-modular","title":"UT3.2 Programaci\u00f3n modular","text":"<p>La programaci\u00f3n modular es un paradigma que consiste en dividir un programa grande y complejo en partes m\u00e1s peque\u00f1as, manejables e independientes, llamadas m\u00f3dulos. Cada m\u00f3dulo se encarga de una tarea espec\u00edfica. En un lenguaje de programaci\u00f3n, estos m\u00f3dulos se implementan como funciones y procedimientos.</p> <p>Las ventajas que ofrece la programaci\u00f3n modular son: - Facilita la resoluci\u00f3n del problema. - Aumenta la claridad y legibilidad de todo el programa. - Permite que varios programadores trabajen en el mismo proyecto. - Reduce el tiempo de desarrollo ya que se pueden reutilizar esos m\u00f3dulos en varios programas. - Aumenta la fiabilidad porque es m\u00e1s sencillo dise\u00f1ar y depurar m\u00f3dulos y el mantenimiento en mas f\u00e1cil.</p> <p>La descomposici\u00f3n modular se basa en la t\u00e9cnica \u201cDivide y Vencer\u00e1s\u201d (DAC o Divide And Conquer), esta t\u00e9cnica tiene dos pasos: - Identificaci\u00f3n de los subproblemas y construcci\u00f3n de los m\u00f3dulos que lo resuelven. - Combinaci\u00f3n de los m\u00f3dulos para resolver el problema original.</p> Concepto de funci\u00f3n"},{"location":"temas/03/3.2-prog-modular.html#321-funciones","title":"3.2.1 Funciones","text":"<p>Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica y devuelve un valor. Las funciones pueden recibir datos de entrada (argumentos) y siempre devuelven un resultado mediante la sentencia <code>return</code>.</p> <pre><code>function int sumar(int a, int b) {\n    // Esta funci\u00f3n toma dos enteros como argumentos y devuelve su suma.\n    return a + b; // Devuelve la suma de a y b\n}\n\nMain {\n    // Llamamos a la funci\u00f3n sumar y almacenamos el resultado en la variable resultado\n    int resultado = sumar(5, 3);\n    System.out.println(\"La suma es: \" + resultado); // Imprime \"La suma es: 8\"\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#322-procedimientos","title":"3.2.2 Procedimientos","text":"<p>Un procedimiento es similar a una funci\u00f3n, pero no devuelve ning\u00fan valor. Se utiliza para ejecutar una serie de instrucciones que realizan una tarea espec\u00edfica. Los procedimientos pueden recibir datos de entrada (argumentos) pero no tienen una sentencia <code>return</code>.</p> <pre><code>procedure saludar(string nombre) {\n    // Este procedimiento toma un nombre como argumento y muestra un saludo personalizado.\n    System.out.println(\"Hola, \" + nombre + \"! Bienvenido al programa.\");\n}\n\nMain {\n    // Llamamos al procedimiento saludar con el nombre \"Ana\"\n    saludar(\"Ana\"); // Imprime \"Hola, Ana! Bienvenido al programa.\"\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#323-parametros-y-argumentos","title":"3.2.3 Par\u00e1metros y Argumentos","text":"<p>Los par\u00e1metros son las variables que se definen en la declaraci\u00f3n de una funci\u00f3n o procedimiento. Act\u00faan como \"marcadores de posici\u00f3n\" para los valores que se pasar\u00e1n cuando se llame a la funci\u00f3n o procedimiento.</p> <p>Los argumentos son los valores reales que se pasan a la funci\u00f3n o procedimiento cuando se llama. Estos valores se asignan a los par\u00e1metros correspondientes.</p> <pre><code>function int multiplicar(int x, int y) {\n    // x e y son los par\u00e1metros de la funci\u00f3n\n    return x * y; // Devuelve el producto de x e y\n}\nMain {\n    // 4 y 5 son los argumentos que se pasan a la funci\u00f3n\n    int resultado = multiplicar(4, 5);\n    System.out.println(\"El producto es: \" + resultado); // Imprime \"El producto es: 20\"\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#la-regla-de-la-exactitud-de-tipos","title":"La Regla de la Exactitud de Tipos","text":"<p>En el Lenguaje Java, se aplica una pol\u00edtica estricta de coincidencia de tipos para garantizar la seguridad y previsibilidad del c\u00f3digo. Esto significa que el tipo de cada argumento pasado debe coincidir exactamente con el tipo de su par\u00e1metro correspondiente.</p> <p>Conversiones (Ampliaci\u00f3n o Estrechamiento)</p> <p>Si un argumento es de un tipo diferente al par\u00e1metro, se considera un error a menos que se use un casting expl\u00edcito para forzar la conversi\u00f3n. Esta regla se aplica incluso en las llamadas \"conversiones de ampliaci\u00f3n\" donde no hay p\u00e9rdida de datos (por ejemplo de de entero a decimal, en este caso no lo permitiremos aunque haya lenguajes que s\u00ed, solo por fines did\u00e1cticos), forzando al programador/a a ser consciente de la transformaci\u00f3n de datos.</p> <ul> <li>Conversiones por ampliaci\u00f3n (de un tipo \"m\u00e1s peque\u00f1o\" a uno \"m\u00e1s grande\"): <code>int</code> a <code>decimal</code> (no permitido sin casting expl\u00edcito).</li> <li>Conversiones por estrechamiento (de un tipo \"m\u00e1s grande\" a uno \"m\u00e1s peque\u00f1o\"): <code>decimal</code> a <code>int</code> (no permitido sin casting expl\u00edcito). Estas conversiones pueden provocar p\u00e9rdida de datos y, por lo tanto, siempre requieren casting expl\u00edcito.</li> </ul> Par\u00e1metro Esperado Argumento Pasado \u00bfV\u00e1lido? Acci\u00f3n Requerida <code>decimal</code> <code>int</code> NO Requiere Casting Expl\u00edcito: <code>(decimal)mi_entero</code> <code>int</code> <code>decimal</code> NO Requiere Casting Expl\u00edcito: <code>(int)mi_decimal</code> <code>int</code> <code>int</code> S\u00cd Paso Directo (Coincidencia Exacta) <code>decimal</code> <code>decimal</code> S\u00cd Paso Directo (Coincidencia Exacta) <code>int?</code> <code>int</code> S\u00cd Paso Directo (Conversi\u00f3n Segura a Anulable) <code>int</code> <code>int?</code> NO Requiere Verificaci\u00f3n y Casting Expl\u00edcito <code>string</code> <code>string</code> S\u00cd Paso Directo (Coincidencia Exacta) <code>string</code> <code>int</code> NO Requiere Casting Expl\u00edcito: <code>(string)mi_char</code> <pre><code>function decimal calcularMedia(decimal a, decimal b) {\n    return (a + b) / 2.0;\n}\n\nMain {\n    int nota1 = 7;\n    int nota2 = 8;\n\n    // ERROR: Se espera decimal, se pasa int. Requiere casting.\n    // decimal resultado = calcularMedia(nota1, nota2); \n\n    // SOLUCI\u00d3N: Usar casting expl\u00edcito para forzar la conversi\u00f3n segura\n    decimal resultado = calcularMedia((decimal)nota1, (decimal)nota2);\n    System.out.println(\"Media: \" + resultado); // Imprime \"Media: 7.5\"\n}\n</code></pre> <p>Resumen de la Regla de la Exactitud de Tipos</p> <p>La exactitud con los tipos de datos que pasas a una funci\u00f3n (<code>int</code>, <code>string</code>, <code>decimal</code>, etc.) permite que tu c\u00f3digo sea seguro, limpio y f\u00e1cil de entender desde el principio.</p> <p>Regla de Oro: Control Total sobre la Transformaci\u00f3n (Tipos Diferentes)</p> <p>Si pasas un dato de un tipo a otro (ej. de <code>int</code> a <code>decimal</code>, o de <code>string</code> a <code>int</code>), siempre debes usar el <code>Casting</code> Expl\u00edcito (<code>(tipo)valor</code>). La regla es que los tipos deben coincidir exactamente, y si no lo hacen, t\u00fa tienes que forzar la conversi\u00f3n.</p> Escenario de Conversi\u00f3n \u00bfPor qu\u00e9 te obligamos al <code>casting</code>? Transformaci\u00f3n Segura (<code>int</code> a <code>decimal</code>) Queremos que seas consciente de que la forma en que se guarda el dato en la memoria cambia. Al usar <code>(decimal)mi_entero</code>, confirmas tu intenci\u00f3n de transformar el dato, incluso si no hay riesgo de p\u00e9rdida. Realmente esta ser\u00eda una transformaci\u00f3n segura por ampliaci\u00f3n en casi todos los lenguajes. Queremos que seas consciente de que la forma en que se guarda el dato cambia. Al escribir (decimal)5, confirmas que quieres que el 5 se convierta en 5.0. \u00a1No queremos magia, queremos control! Transformaci\u00f3n Peligrosa (<code>decimal</code> a <code>int</code>, <code>string</code> a <code>int</code>) Hay un alto riesgo de p\u00e9rdida de informaci\u00f3n (ej. quitar decimales) o un fallo (ej. si el <code>string</code> es \"hola\"). El casting te obliga a asumir la responsabilidad de que el valor pueda ser corrupto o causar un error. en definitiva, est\u00e1s haciendo una Conversi\u00f3n Peligrosa (estrechamiento). Quitas los decimales (truncamiento). Esto es una p\u00e9rdida de datos y no suele estar permitida por los lenguajes. El casting obligatorio te obliga a asumir la responsabilidad de esa p\u00e9rdida. <p>Conclusi\u00f3n: El casting expl\u00edcito siempre es tu herramienta para controlar y documentar cualquier cambio en el formato de los datos. Si los tipos no son id\u00e9nticos, \u00a1el control es tuyo! Es una cuesti\u00f3n de disciplina y claridad.</p>"},{"location":"temas/03/3.2-prog-modular.html#324-paso-por-valor-y-paso-por-referencia","title":"3.2.4 Paso por valor y paso por referencia","text":"<p>Esta es una de las distinciones m\u00e1s importantes sobre c\u00f3mo se pasan los argumentos a los m\u00f3dulos:</p> <ul> <li>Paso por valor (por defecto): Cuando pasas un argumento por valor, la funci\u00f3n recibe una copia del dato original. Cualquier modificaci\u00f3n que hagas al par\u00e1metro dentro de la funci\u00f3n no afectar\u00e1 a la variable original fuera de ella. Este es el comportamiento por defecto en la mayor\u00eda de los lenguajes de programaci\u00f3n, incluido DAW.</li> </ul> <pre><code>  function int incrementar(int numero) {\n      // Esta funci\u00f3n recibe una copia del valor original.\n      numero = numero + 1; // Incrementa la copia, no el original.\n      return numero; // Devuelve el valor incrementado.\n  }\n\n  Main {\n      var valorOriginal = 10;\n      System.out.println(\"Valor original antes de la funci\u00f3n: \" + valorOriginal); // Imprime 10\n      var nuevoValor = incrementar(valorOriginal);\n      System.out.println(\"Valor devuelto por la funci\u00f3n: \" + nuevoValor); // Imprime 11\n      System.out.println(\"Valor original despu\u00e9s de la funci\u00f3n: \" + valorOriginal); // Sigue imprimiendo 10\n  }\n</code></pre> <ul> <li> <p>Paso por referencia: Cuando pasas un argumento por referencia, en lugar de una copia, la funci\u00f3n recibe la direcci\u00f3n de memoria de la variable original. Esto significa que cualquier cambio que hagas al par\u00e1metro dentro de la funci\u00f3n modificar\u00e1 directamente la variable original.</p> <pre><code>void duplicar(int numero) {\n    // Esta funci\u00f3n recibe una referencia al valor original.\n    numero = numero * 2; // Modifica directamente el valor original.\n}\n\nMain {\n    String valorOriginal = 10;\n\n    System.out.println(\"Valor original antes de la funci\u00f3n: \" + valorOriginal); // Imprime 10\n    duplicar(valorOriginal); // Pasamos la variable por referencia\n    System.out.println(\"Valor original despu\u00e9s de la funci\u00f3n: \" + valorOriginal); // Ahora imprime 20\n}\n</code></pre> <p></p> </li> </ul> <p>En Java, el mecanismo de paso de par\u00e1metros a los m\u00e9todos es a menudo una fuente de confusi\u00f3n:</p> <ol> <li> <p>Tipos Primitivos (como <code>int</code>, <code>boolean</code>, <code>double</code>, etc.): Se pasan siempre por valor. Se crea una copia del valor de la variable original y esa copia es la que se pasa al m\u00e9todo. Cualquier modificaci\u00f3n dentro del m\u00e9todo afecta solo a esa copia local, no a la variable original. *</p> </li> <li> <p>Objetos (Tipos de Referencia, como instancias de clases): Se pasan por valor de la referencia (a veces llamado \"paso por copia de la referencia\" o pass-by-value of the reference). Esto significa:</p> <ul> <li>La variable que se pasa al m\u00e9todo contiene la direcci\u00f3n de memoria (la referencia) donde reside el objeto.</li> <li>El m\u00e9todo recibe una copia de esta referencia (la direcci\u00f3n de memoria).</li> <li>Si usas esta copia de la referencia dentro del m\u00e9todo para modificar el estado interno del objeto (por ejemplo, llamar a un setter), el objeto original s\u00ed se ver\u00e1 afectado, porque ambas referencias apuntan al mismo objeto en la memoria heap.</li> <li>Sin embargo, si dentro del m\u00e9todo reasignas la variable de referencia a un nuevo objeto, esto solo cambiar\u00e1 la referencia local dentro del m\u00e9todo; la referencia original en el c\u00f3digo llamador permanecer\u00e1 sin cambios, apuntando al objeto original.</li> </ul> </li> </ol> <p>\ud83d\udca1 Un <code>String</code> no es un objeto primitivo y por tanto se pasa por referencia. Adem\u00e1s los <code>String</code> son inmutables. No se pueden modificar, si queremos modificar se necesita crear una copia de ellos.</p>"},{"location":"temas/03/3.2-prog-modular.html#325-ambito-de-las-variables","title":"3.2.5. \u00c1mbito de las variables","text":"<p>El \u00e1mbito (o alcance) de una variable determina d\u00f3nde puede ser accedida o modificada dentro del c\u00f3digo. </p> <ul> <li> <p>\u00c1mbito global: Las variables declaradas fuera de cualquier funci\u00f3n o procedimiento tienen \u00e1mbito global. Esto significa que pueden ser accedidas y modificadas desde cualquier parte del programa, incluyendo dentro de funciones y procedimientos. Sin embargo, abusar de las variables globales puede llevar a c\u00f3digo dif\u00edcil de mantener y depurar, ya que cualquier parte del programa puede cambiar su valor. Usa las variables globales con moderaci\u00f3n y solo cuando sea absolutamente necesario, aunque es mejor no hacerlo.</p> </li> <li> <p>\u00c1mbito local: Las variables declaradas dentro de una funci\u00f3n o procedimiento tienen \u00e1mbito local. Solo pueden ser accedidas y modificadas dentro de ese bloque espec\u00edfico. Esto ayuda a evitar conflictos de nombres y hace que el c\u00f3digo sea m\u00e1s modular y f\u00e1cil de entender.</p> </li> </ul> <pre><code>int contadorGlobal = 0; // Variable global, OJO que puedes suspender por usarlas, porque siempre se puede usar paso por referencia si lo necesitas\n\nvoid incrementarContador() {\n    int contadorLocal = 0; // Variable local\n\n    contadorLocal = contadorLocal + 1; // Incrementa la variable local\n    contadorGlobal = contadorGlobal + 1; // Incrementa la variable global\n\n    System.out.println(\"Contador local: \" + contadorLocal); // Siempre imprimir\u00e1 1\n    System.out.println(\"Contador global: \" + contadorGlobal); // Incrementa cada vez que se llama a la funci\u00f3n\n}\n\nMain {\n    incrementarContador(); // Llama a la funci\u00f3n\n    incrementarContador(); // Llama a la funci\u00f3n de nuevo\n    incrementarContador(); // Llama a la funci\u00f3n de nuevo\n}\n</code></pre> <p>Es importante entender que puedes tener variables que se llamen igual en diferentes \u00e1mbitos (una en Main y otra local, ya sea funci\u00f3n/procedimiento y bucle, o if), pero son variables completamente distintas. La variable local \"oculta\" a la global dentro de su \u00e1mbito.</p> <pre><code>int valor = 100; // Variable global\n\nvoid mostrarValor() {\n    int valor = 50; // Variable local, oculta a la global\n    System.out.println(\"Valor dentro de la funci\u00f3n: \" + valor); // Imprime 50\n}\n\nMain {\n    int valor = 75; // Variable local en Main, oculta a la global\n\n    System.out.println(\"Valor en Main: \" + valor); // Imprime 75\n\n    mostrarValor(); // Llama a la funci\u00f3n que imprime 50\n\n    System.out.println(\"Valor global: \" + valor); // Imprime 75, la variable global sigue siendo 100 \n    System.out.println(\"Valor global accedido directamente: \" + 100); \n\n    if (valor &gt; 50) {\n        int valor = 25; // Variable local en el if, oculta a la de Main\n\n        // Para evitar estas cosas nombra bien tus variables y no repitas nombres\n        System.out.println(\"Valor dentro del if: \" + valor); // Imprime 25\n    }\n\n    System.out.println(\"Valor en Main despu\u00e9s del if: \" + valor); // Imprime\n\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#326-sobrecarga-de-funciones-y-procedimientos","title":"3.2.6 Sobrecarga de funciones y procedimientos","text":"<p>La sobrecarga permite definir m\u00faltiples funciones o procedimientos con el mismo nombre, pero con diferentes listas de par\u00e1metros (diferente n\u00famero o tipos de par\u00e1metros). El compilador determina cu\u00e1l funci\u00f3n llamar en funci\u00f3n de los argumentos proporcionados.</p> <pre><code>int calcularArea(int lado) {\n    // Calcula el \u00e1rea de un cuadrado\n    return lado * lado;\n}\n\ndecimal calcularArea(decimal radio) {\n    // Calcula el \u00e1rea de un c\u00edrculo\n    return 3.1416 * radio * radio;\n}\n\nMain {\n    int areaCuadrado = calcularArea(5); // Llama a la funci\u00f3n para cuadrado\n    decimal areaCirculo = calcularArea(3.5); // Llama a la funci\u00f3n para c\u00edrculo\n\n    System.out.println(\"\u00c1rea del cuadrado: \" + areaCuadrado); // Imprime 25\n    System.out.println(\"\u00c1rea del c\u00edrculo: \" + areaCirculo); // Imprime aproximadamente 38.4846\n}\n</code></pre> <p>En cualquier caso, la sobrecarga debe usarse con moderaci\u00f3n para evitar confusiones. Aseg\u00farate de que las funciones sobrecargadas tengan una l\u00f3gica clara y distinta para que su uso sea intuitivo. Si no siempre podr\u00e1s usar nombres diferentes para cada funci\u00f3n o procedimiento o usar par\u00e1metros opcionales o por defecto y nombrados para evitar tanto su uso.</p>"},{"location":"temas/03/3.2-prog-modular.html#327-parametros-de-salida","title":"3.2.7 Par\u00e1metros de salida","text":"<p>Permiten que una funci\u00f3n o procedimiento devuelva m\u00faltiples valores. Se declaran con la palabra clave <code>out</code> y deben ser asignados dentro de la funci\u00f3n antes de que esta termine. Al llamar a la funci\u00f3n, no es necesario inicializar las variables que se pasan como par\u00e1metros de salida. No es una pr\u00e1ctica muy com\u00fan, pero es \u00fatil en ciertos casos donde necesitas devolver varios valores sin usar estructuras o clases y no se recomienda salvo que sea estrictamente necesario.</p> <p>\u00bfQue diferencia hay en usar <code>out</code> o <code>ref</code>? Que con <code>ref</code> la variable debe estar inicializada antes de pasarla a la funci\u00f3n, mientras que con <code>out</code> no es necesario inicializarla, pero dentro de la funci\u00f3n debe ser asignada antes de salir de ella.</p> <pre><code>function void obtenerDatos(out string nombre, out int edad) {\n    // Asignamos valores a los par\u00e1metros de salida\n    nombre = \"Ana\";\n    edad = 25;\n}\n\nMain {\n    string nombre;\n    int edad;\n    obtenerDatos(out nombre, out edad);\n    System.out.println(\"Nombre: \" + nombre);\n    System.out.println(\"Edad: \" + edad);\n}\n</code></pre> <p>Aqu\u00ed la diferencia con <code>ref</code> es que no es necesario inicializar <code>nombre</code> y <code>edad</code> antes de pasarlas a la funci\u00f3n, pero dentro de la funci\u00f3n deben ser asignadas antes de que esta termine.</p> <pre><code>function void obtenerDatos(ref string nombre, ref int edad) {\n    // Asignamos valores a los par\u00e1metros de referencia\n    nombre = \"Ana\";\n    edad = 25;\n}\n\nMain {\n    string nombre = \"\"; // Debe estar inicializada\n    int edad = 0; // Debe estar inicializada\n    obtenerDatos(ref nombre, ref edad);\n    System.out.println(\"Nombre: \" + nombre);\n    System.out.println(\"Edad: \" + edad);\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#3291-paso-por-referencia-vs-paso-por-salida-ref-vs-out","title":"3.2.9.1. Paso por Referencia vs. Paso por Salida (<code>ref</code> vs. <code>out</code>)","text":"<p>Tanto <code>ref</code> como <code>out</code> son mecanismos de Paso por Referencia, lo que significa que en lugar de pasar una copia del valor, la funci\u00f3n trabaja directamente con la variable original en la memoria, permitiendo que el m\u00f3dulo modifique su valor.</p> <p>Sin embargo, no son sin\u00f3nimos. La diferencia clave est\u00e1 en su prop\u00f3sito (sem\u00e1ntica) y, lo m\u00e1s importante, en el Control de Compilaci\u00f3n que imponen para garantizar la seguridad.</p> Caracter\u00edstica \ud83d\udd11 <code>ref</code> (Referencia) \ud83d\udd11 <code>out</code> (Salida) Flujo de Datos Entrada y Salida (I/O). Modifica un valor existente. Solo Salida (O). Se usa para obtener un resultado. Inicializaci\u00f3n (en <code>Main</code>) El argumento DEBE estar inicializado antes de la llamada. El argumento NO necesita estar inicializado. Asignaci\u00f3n (en Funci\u00f3n) La funci\u00f3n puede leer y modificar el par\u00e1metro, pero no est\u00e1 obligada a modificarlo. La funci\u00f3n DEBE asignar un valor antes de finalizar su ejecuci\u00f3n. \u00a1Es una obligaci\u00f3n impuesta por el compilador! Concepto Clave Modificar un valor existente. Devolver uno o varios resultados adicionales."},{"location":"temas/03/3.2-prog-modular.html#1-uso-de-ref-modificar-una-entrada-existente","title":"1. Uso de <code>ref</code>: Modificar una Entrada Existente","text":"<p><code>ref</code> se utiliza cuando el valor inicial del argumento es importante para la funci\u00f3n, la cual lo usar\u00e1 como entrada y luego, opcionalmente, lo modificar\u00e1.</p> <pre><code>// 'saldo' entra valiendo 100, y sale valiendo 150.\nprocedure depositar(ref decimal saldo, decimal cantidad) {\n    // La funci\u00f3n LEY\u00d3 el valor de 'saldo' (100) para calcular la suma.\n    saldo = saldo + cantidad; \n}\n\nMain {\n    decimal miCuenta = 100.0m; // DEBE estar inicializada\n    depositar(ref miCuenta, 50.0m);\n    // miCuenta ahora vale 150.0m.\n}\n</code></pre> <p>Regla esencial: La variable <code>miCuenta</code> debe haber sido inicializada antes de la llamada, pues la funci\u00f3n <code>depositar</code> necesita leer su valor inicial.</p>"},{"location":"temas/03/3.2-prog-modular.html#2-uso-de-out-garantizar-un-resultado-obligatorio","title":"2. Uso de <code>out</code>: Garantizar un Resultado Obligatorio","text":"<p><code>out</code> se utiliza para devolver resultados adicionales y es la forma principal de devolver m\u00faltiples valores. Es superior a <code>ref</code> en este contexto porque el compilador lo supervisa:</p> <ul> <li>Sem\u00e1ntica (Intenci\u00f3n): Al usar <code>out</code>, aclaras que esa variable solo se usar\u00e1 para obtener un resultado, ignorando si ten\u00eda un valor inicial en el <code>Main</code>.</li> <li>Control de Compilaci\u00f3n (Seguridad): La regla de <code>out</code> obliga a que todos los caminos posibles dentro de la funci\u00f3n asignen un valor a ese par\u00e1metro. Esto previene que la funci\u00f3n termine sin haber devuelto un resultado v\u00e1lido.</li> </ul> <pre><code>// 'resultado' solo sirve como contenedor para DEVOLVER un valor.\nfunction bool intentarDividir(int num, int den, out decimal resultado) {\n    if (den == 0) {\n        resultado = 0.0m; // Asignaci\u00f3n obligatoria 1\n        return false;\n    }\n    resultado = (decimal)num / den; // Asignaci\u00f3n obligatoria 2\n    return true;\n}\n\nMain {\n    decimal division; // No es necesario inicializarla\n\n    bool exito = intentarDividir(10, 2, out division);\n    // division ahora vale 5.0m.\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#contraejemplo-la-obligacion-de-asignacion-de-out","title":"Contraejemplo: La Obligaci\u00f3n de Asignaci\u00f3n de <code>out</code>","text":"<p>Si no asignas un valor al par\u00e1metro <code>out</code> en todos los flujos de control (por ejemplo, en un <code>if</code> pero no en el <code>else</code>), el compilador generar\u00e1 un error, incluso si la variable tuviera un valor inicial en el <code>Main</code> (ese valor inicial es ignorado).</p> <p>El siguiente c\u00f3digo producir\u00eda un ERROR DE COMPILACI\u00d3N:</p> <pre><code>// \u00a1ERROR! Si 'dato' es menor que 10, la funci\u00f3n sale sin asignar 'mensaje'.\nfunction bool procesarDatos(int dato, out string mensaje) {\n    if (dato &gt; 10) {\n        mensaje = \"Dato procesado con \u00e9xito.\"; // Asignaci\u00f3n OK\n        return true;\n    } \n\n    // El compilador no permite salir por aqu\u00ed porque 'mensaje' \n    // no ha recibido un valor garantizado.\n    return false;\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#3210-resumen","title":"3.2.10 Resumen","text":"Concepto Clave Palabra Clave DAW Regla / Uso Obligatorio Impacto en el C\u00f3digo Declaraci\u00f3n <code>function</code> o <code>procedure</code> Funci\u00f3n: Debe devolver un valor (<code>return</code>). Procedimiento: No devuelve valor (similar a <code>void</code>). Define la estructura de tu m\u00f3dulo de c\u00f3digo. --- --- --- --- Sobrecarga (Misma funci\u00f3n) Definir varias funciones/procedimientos con el mismo nombre, pero con diferentes par\u00e1metros (cantidad o tipo). Permite usar un nombre simple (<code>Sumar</code>) para operaciones que manejan diferentes tipos de datos (ej. <code>int</code> o <code>decimal</code>). Par\u00e1metros Variables <code>params tipo nombre</code> Permite que el \u00faltimo par\u00e1metro de la funci\u00f3n reciba un n\u00famero indeterminado de argumentos del mismo tipo. Crea funciones muy flexibles que pueden aceptar 1, 5 o 100 argumentos. Recorremos con <code>foreach</code>. --- --- --- --- Coincidencia de Tipos N/A Los tipos de los argumentos y par\u00e1metros deben ser EXACTOS. Garantiza la m\u00e1xima seguridad y control. Conversi\u00f3n de Tipos <code>(tipo)</code> Casting Expl\u00edcito Obligatorio si los tipos son diferentes (ej. <code>(decimal)mi_int</code>). Te obliga a ser consciente de la transformaci\u00f3n y p\u00e9rdida de datos. Tipos Anulables <code>T?</code> Paso Seguro: Se permite <code>int</code> a <code>int?</code> sin casting. Paso Prohibido: Est\u00e1 prohibido <code>int?</code> a <code>int</code> sin verificaci\u00f3n. Evita errores de <code>null</code> inesperados. --- --- --- --- Paso por Valor (Por defecto) Pasa una COPIA del valor del argumento. Los cambios dentro de la funci\u00f3n NO afectan a la variable original. Paso por Referencia <code>ref</code> Se debe usar <code>ref</code> en la definici\u00f3n y en la llamada. Pasa la direcci\u00f3n de memoria. Los cambios dentro de la funci\u00f3n S\u00cd afectan a la variable original. Paso de Salida <code>out</code> Se usa <code>out</code> en la definici\u00f3n y en la llamada. La variable NO necesita estar inicializada antes de llamar. Se debe asegurar que se ha inicializado al salir de la funci\u00f3n. Permite a un procedimiento devolver varios valores. --- --- --- --- Argumentos Nombrados <code>nombre_parametro: valor</code> Permite especificar el argumento por su nombre. Mejora la legibilidad en llamadas con muchos par\u00e1metros. Par\u00e1metros Opcionales <code>tipo nombre = valor_defecto</code> El par\u00e1metro toma un valor por defecto si no se le pasa un argumento. Permite crear funciones m\u00e1s flexibles sin sobrecarga."},{"location":"temas/03/3.2-prog-modular.html#3210-reflexiones-el-contrato-de-la-funcion","title":"3.2.10 Reflexiones: El Contrato de la Funci\u00f3n","text":"<p>Es vital reflexionar sobre la gesti\u00f3n de tipos en DAW, ya que hemos introducido una regla que parece contradecir el comportamiento simple del lenguaje que vimos en el tema anterior y que aplicamos en el bloque <code>Main</code>.</p>"},{"location":"temas/03/3.2-prog-modular.html#1-tipos-en-el-ambito-local-main-comodidad-y-seguridad-por-diseno","title":"1. Tipos en el \u00c1mbito Local (<code>Main</code>): Comodidad y Seguridad por Dise\u00f1o","text":"<p>Cuando realizas una asignaci\u00f3n de variable simple en el bloque <code>Main</code>, DAW te ofrece flexibilidad, pero solo hasta cierto punto:</p> <ul> <li>Conversi\u00f3n por Ampliaci\u00f3n (Segura) Permitida: Puedes asignar un valor de un tipo m\u00e1s peque\u00f1o a un tipo m\u00e1s grande (ej. <code>int</code> a <code>decimal</code>) sin casting. El riesgo es nulo, ya que el dato cabe perfectamente sin perder informaci\u00f3n. El lenguaje te ayuda en el d\u00eda a d\u00eda.<ul> <li>Lo que Ense\u00f1a: Que los tipos tienen una jerarqu\u00eda de tama\u00f1o y la m\u00e1quina puede realizar transformaciones seguras por ti.</li> </ul> </li> </ul> <pre><code>Main {\n    int mi_entero = 5;\n    decimal mi_decimal = mi_entero; // Conversi\u00f3n segura, no necesita casting\n    System.out.println(\"Decimal: \" + mi_decimal); // Imprime \"Decimal: 5.0\"\n}\n</code></pre> <ul> <li>Conversi\u00f3n por Estrechamiento Prohibida: Nunca puedes asignar un tipo grande a uno peque\u00f1o (ej. <code>decimal</code> a <code>int</code>) sin casting. El compilador lo proh\u00edbe.<ul> <li>Lo que Ense\u00f1a: Que la p\u00e9rdida de datos (truncamiento) es un riesgo que solo t\u00fa, como programador/a, puedes autorizar expl\u00edcitamente usando <code>(int)</code>.</li> </ul> </li> </ul> <pre><code>Main {\n    decimal mi_decimal = 5.7;\n    // int mi_entero = mi_decimal; // ERROR: Conversi\u00f3n peligrosa, necesita casting\n    int mi_entero = (int)mi_decimal; // Necesita casting expl\u00edcito\n    System.out.println(\"Entero: \" + mi_entero); // Imprime \"Entero: 5\"\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#2-tipos-en-la-interfaz-modular-el-contrato-estricto","title":"2. Tipos en la Interfaz Modular: El Contrato Estricto","text":"<p>En la Programaci\u00f3n Modular, el paso de argumentos a una funci\u00f3n o procedimiento es diferente. Aqu\u00ed, la regla de oro es la estrictez y la coincidencia exacta de tipos, incluso para las conversiones seguras (<code>int</code> a <code>decimal</code>) que antes eran v\u00e1lidas o parecen triviales (por conversi\u00f3n por ampliaci\u00f3n).</p> <p>Esta decisi\u00f3n pedag\u00f3gica, aunque pueda parecer una \"inconsistencia\" con el <code>Main</code>, es la base de la disciplina de programaci\u00f3n superior que necesitas aprender. \u00bfPor qu\u00e9? Esto nos prepara para el desarrollo profesional, donde las librer\u00edas y APIs exigen contratos claros y sin ambig\u00fcedades.</p>"},{"location":"temas/03/3.2-prog-modular.html#a-por-que-es-sagrado-el-contrato-de-una-funcion","title":"A. \u00bfPor qu\u00e9 es Sagrado el Contrato de una Funci\u00f3n?","text":"<p>La llamada a una funci\u00f3n es el contrato entre tu c\u00f3digo y el m\u00f3dulo que has creado. Este contrato debe ser inviolable y expl\u00edcito para evitar ambig\u00fcedades y errores.</p> Regla Estricta Por qu\u00e9 Ayuda al Programador Evitar Ambig\u00fcedad en Sobrecarga Al forzar el casting expl\u00edcito (ej. <code>calcular((decimal)x, y)</code>), le est\u00e1s diciendo al compilador exactamente qu\u00e9 versi\u00f3n de la funci\u00f3n quieres usar si existen varias con el mismo nombre (<code>sobrecarga</code>). Esto elimina las dudas de la m\u00e1quina. Fomentar la Conciencia de la Interfaz Para saber si necesitas o no un casting, te obligas a consultar la firma (nombre y par\u00e1metros) de la funci\u00f3n. Un buen desarrollador siempre conoce los requerimientos de los m\u00f3dulos que utiliza. Preparaci\u00f3n para el Mundo Real Las librer\u00edas y APIs profesionales exigen esta estrictez de tipado. Adquirir este h\u00e1bito te prepara para crear software s\u00f3lido y mantenible, es decir c\u00f3digo robusto, predecible yofesional"},{"location":"temas/03/3.2-prog-modular.html#regla-de-oro-de-la-modularidad","title":"Regla de Oro de la Modularidad","text":"<p>\"Los m\u00f3dulos son m\u00e1s estrictos porque exigen el m\u00e1ximo control. En una funci\u00f3n o procedimiento, no puedes dar nada por sentado. La disciplina y la exactitud son obligatorias en las interfaces y m\u00f3dulos (procedimientos y funciones) para que tu programa sea robusto y escalable.</p> <p>Tu c\u00f3digo solo pierde el control cuando no sabes exactamente qu\u00e9 valor o tipo est\u00e1 procesando un m\u00f3dulo. Al ser estricto con el contrato de la funci\u00f3n, garantizas la fiabilidad de la interfaz y previenes que los errores de tipo se propaguen silenciosamente por tu programa.</p> <p>Cuando llames a una funci\u00f3n, la interfaz es sagrada. Con ello, evitas errores en las llamadas a funciones sobrecargadas y te aseguras de que sabes exactamente qu\u00e9 est\u00e1s pasando, con ello aprenderemos a hacer c\u00f3digo seguro, predecible y profesional.\"</p>"},{"location":"temas/03/3.2-prog-modular.html#3212-early-return-para-simplificar-condicionales","title":"3.2.12. Early Return para simplificar condicionales","text":"<p>Este apartado, aunque conceptualmente es una t\u00e9cnica de dise\u00f1o que se aplica dentro de la Programaci\u00f3n Modular (ya que el <code>return</code> se utiliza para la salida de funciones), su objetivo es simplificar dr\u00e1sticamente las estructuras de control condicionales (<code>if-else</code> anidadas).</p> <p>Aqu\u00ed teniendo funciones y procedimientos ya definidos, podemos usar <code>return</code> para salir anticipadamente de una funci\u00f3n cuando se cumple una condici\u00f3n espec\u00edfica, evitando as\u00ed anidar m\u00faltiples niveles de <code>if-else</code>.</p> <p>El Teorema Fundamental de la Programaci\u00f3n Estructurada establece que todo programa debe tener un \u00fanico punto de entrada y un \u00fanico punto de salida. Si bien el uso del <code>return</code> fuera del final de una funci\u00f3n (salida anticipada) t\u00e9cnicamente podr\u00eda considerarse una desviaci\u00f3n de este ideal te\u00f3rico para fines de flujo de control, en la pr\u00e1ctica moderna es aceptado para mejorar la legibilidad y evitar la complejidad del \"efecto cascada\" en las estructuras <code>if-else</code>.</p> <p>La t\u00e9cnica de Salida Anticipada (Early Return) consiste en utilizar la sentencia <code>return</code> para terminar inmediatamente la ejecuci\u00f3n de una funci\u00f3n o procedimiento tan pronto como se haya cumplido una condici\u00f3n que hace innecesaria la ejecuci\u00f3n del c\u00f3digo restante.</p>"},{"location":"temas/03/3.2-prog-modular.html#ventajas-del-early-return-para-condicionales","title":"Ventajas del Early Return para Condicionales","text":"<p>Esta t\u00e9cnica es especialmente \u00fatil para:</p> <ol> <li>Validaci\u00f3n de Entradas (Guard Clauses): Permite verificar condiciones fallidas o datos inv\u00e1lidos al comienzo de una funci\u00f3n y salir de inmediato.</li> <li>Aplanar Estructuras Anidadas: Evita la necesidad de anidar estructuras <code>if-else if-else</code> complejas, haciendo el c\u00f3digo m\u00e1s claro y reduciendo los niveles de indentaci\u00f3n, evitar el efecto cascada o \"Hadouken\".</li> </ol> <p>Dado que la sentencia <code>return</code> solo es v\u00e1lida dentro de funciones, los ejemplos deben implementarse dentro de funciones llamadas desde <code>Main</code>.</p>"},{"location":"temas/03/3.2-prog-modular.html#ejemplo-1-evitar-anidamiento-en-la-validacion","title":"Ejemplo 1: Evitar anidamiento en la validaci\u00f3n","text":"<p>Supongamos que necesitamos calcular algo solo si dos n\u00fameros son positivos.</p> <p>Sin Salida Anticipada (Anidamiento complejo):</p> <pre><code>Main {\n    System.out.println(\"Ejemplo 1A: Sin Early Return\");\n\n    // Llamada a la funci\u00f3n con anidamiento\n    int resultado = calcularSiPositivos(5, 3);\n    System.out.println(\"Resultado: \" + resultado);\n\n    resultado = calcularSiPositivos(-5, 3);\n    System.out.println(\"Resultado: \" + resultado);\n}\n\n// Funci\u00f3n que calcula la suma solo si ambos son positivos (mucho anidamiento)\nint calcularSiPositivos(int a, int b) {\n    if (a &gt; 0) \n    {\n        if (b &gt; 0) \n        {\n            // L\u00f3gica principal\n            return a + b;\n        } \n        else \n        {\n            System.out.println(\"Error: El segundo n\u00famero no es positivo.\");\n            return 0;\n        }\n    } \n    else \n    {\n        System.out.println(\"Error: El primer n\u00famero no es positivo.\");\n        return 0;\n    }\n}\n</code></pre> <p>Con Salida Anticipada (L\u00f3gica aplanada):</p> <pre><code>Main {\n    System.out.println(\"Ejemplo 1B: Con Early Return\");\n\n    // Llamada a la funci\u00f3n con salida anticipada\n    int resultado = calcularConEarlyReturn(5, 3);\n    System.out.println(\"Resultado: \" + resultado);\n\n    resultado = calcularConEarlyReturn(-5, 3);\n    System.out.println(\"Resultado: \" + resultado);\n}\n\n// Funci\u00f3n que valida y usa early return\nint calcularConEarlyReturn(int a, int b) {\n    // 1. Validaci\u00f3n del primer error (Salida anticipada)\n    if (a &lt;= 0) \n    {\n        System.out.println(\"Error: El primer n\u00famero no es positivo.\");\n        return 0; // Se sale de la funci\u00f3n inmediatamente\n    }\n\n    // 2. Validaci\u00f3n del segundo error (Salida anticipada)\n    if (b &lt;= 0) \n    {\n        System.out.println(\"Error: El segundo n\u00famero no es positivo.\");\n        return 0; // Se sale de la funci\u00f3n inmediatamente\n    }\n\n    // L\u00f3gica principal: Solo se ejecuta si NINGUNA de las condiciones anteriores se cumpli\u00f3\n    System.out.println(\"Validaci\u00f3n exitosa. Calculando...\");\n    return a + b;\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#ejemplo-2-romper-una-cadena-de-validacion-compleja","title":"Ejemplo 2: Romper una cadena de validaci\u00f3n compleja","text":"<p>La salida anticipada permite gestionar los errores m\u00e1s comunes o condiciones triviales al principio de la funci\u00f3n.</p> <pre><code>Main {\n    System.out.println(\"Ejemplo 2: Validar un PIN\");\n\n    // Declaraci\u00f3n de variables dentro de Main\n    int pin = 1234;\n    bool esValido = validarPinEarlyReturn(pin);\n    System.out.println(\"PIN 1234 es v\u00e1lido: \" + esValido);\n\n    pin = 55;\n    esValido = validarPinEarlyReturn(pin);\n    System.out.println(\"PIN 55 es v\u00e1lido: \" + esValido);\n}\n\n// Procedimiento de validaci\u00f3n que devuelve un booleano (true/false)\nbool validarPinEarlyReturn(int pin) {\n    // 1. Salida Anticipada: El PIN debe ser positivo\n    if (pin &lt;= 0) \n    {\n        System.out.println(\"PIN no puede ser negativo o cero.\");\n        return false;\n    }\n\n    // 2. Salida Anticipada: El PIN debe tener 4 cifras (simulaci\u00f3n)\n    if (pin &lt; 1000 || pin &gt; 9999) \n    {\n        System.out.println(\"El PIN debe ser de 4 cifras.\");\n        return false;\n    }\n\n    // 3.2. L\u00f3gica principal: Si llegamos aqu\u00ed, el PIN cumple todas las reglas de formato, no ha salido antes\n    System.out.println(\"PIN con formato correcto.\");\n    return true; \n}\n\n// Ahora mira mos c\u00f3mo ser\u00eda sin Early Return\nbool validarPinSinEarlyReturn(int pin) {\n    if (pin &lt;= 0) {\n        // 1. Validaci\u00f3n del primer error\n        System.out.println(\"PIN no puede ser negativo o cero.\");\n        return false;\n    } else {\n            // 2. Validaci\u00f3n del segundo error\n        if (pin &lt; 1000 || pin &gt; 9999) {\n            System.out.println(\"El PIN debe ser de 4 cifras.\");\n            return false;\n        } else {\n            // 3.2. L\u00f3gica principal\n            System.out.println(\"PIN con formato correcto.\");\n            return true;\n        }\n    }\n}\n</code></pre> <p>Recuerda que el uso de <code>return</code> para salir anticipadamente solo es v\u00e1lido dentro de funciones y procedimientos, no en bloques de c\u00f3digo como <code>if</code>, <code>for</code>, o <code>while</code>. Por lo tanto, esta t\u00e9cnica se aplica exclusivamente en el contexto de funciones y procedimientos.</p> <p></p> <p></p>"},{"location":"temas/03/3.2-prog-modular.html#32132-recursividad","title":"3.2.13.2. Recursividad","text":"<p>La recursividad es una t\u00e9cnica que consiste en llamar a una funci\u00f3n o procedimiento dentro de s\u00ed mismo. La funci\u00f3n o procedimiento se llama a s\u00ed misma hasta que se cumple una condici\u00f3n que hace que la funci\u00f3n o procedimiento deje de llamarse a s\u00ed misma (condici\u00f3n de parada o salida). Es importante siempre mostrar la condici\u00f3n de parada.</p> <p></p> <p>Muchos problemas son mucho m\u00e1s sencillos de resolver con recursividad que con iteraci\u00f3n. Por ejemplo, el c\u00e1lculo de un factorial es mucho m\u00e1s sencillo de resolver con recursividad que con iteraci\u00f3n.</p> <pre><code>function int factorial(int n) {\n    // Condici\u00f3n de parada\n    if (n &lt;= 1) {\n        return 1;\n    } else {\n        // Llamada recursiva\n        return n * factorial(n - 1);\n    }\n}\nMain {\n    int numero = 5;\n    int resultado = factorial(numero);\n    System.out.println(\"El factorial de \" + numero + \" es \" + resultado); // Imprime 120\n}\n</code></pre> <p></p>"},{"location":"temas/03/3.2-prog-modular.html#3214-paquete-o-modulo","title":"3.2.14. Paquete o m\u00f3dulo","text":"<p>Un paquete o m\u00f3dulo (tambi\u00e9n conocido como librer\u00eda) es un archivo o conjunto de archivos que agrupa funciones, procedimientos y tipos de datos relacionados. Sirven para organizar el c\u00f3digo por funcionalidades y poder reutilizarlo f\u00e1cilmente en distintos proyectos. Hay muchas librer\u00edas est\u00e1ndar que vienen con el lenguaje DAW, y tambi\u00e9n puedes crear tus propias librer\u00edas para compartir c\u00f3digo entre diferentes programas, una de ellas es <code>Math</code> que contiene funciones matem\u00e1ticas comunes como <code>sqrt</code> (ra\u00edz cuadrada) y <code>random</code> (n\u00famero aleatorio) entre otras: sin(), cos(), tan(), pow(), log(), etc.</p> <p>Para usar las funcionalidades de un m\u00f3dulo en nuestro programa, primero debemos importarlo. En el lenguaje DAW, usaremos la palabra clave <code>using</code>.</p> <pre><code>// Imaginemos que existe un m\u00f3dulo llamado \"Math\".\n// Lo importamos al principio de nuestro programa con 'using'.\nusing Math;\n\nMain {\n    // --- Ejemplo con la funci\u00f3n sqrt ---\n    decimal numero = 16.0;\n    // Usamos la funci\u00f3n sqrt del m\u00f3dulo Math\n    decimal raiz = Math.sqrt(numero);\n    System.out.println(\"La ra\u00edz cuadrada de \" + numero + \" es \" + raiz);\n\n    // --- Ejemplo con la funci\u00f3n random ---\n    // Generamos un n\u00famero entero aleatorio entre 1 y 6 (ambos inclusive)\n    int numeroAleatorio = Math.random(1, 6);\n    System.out.println(\"Lanzamiento de un dado: \" + numeroAleatorio);\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#3215-control-de-excepciones","title":"3.2.15. Control de excepciones","text":"<p>El control de excepciones es una t\u00e9cnica de programaci\u00f3n esencial para manejar errores que ocurren durante la ejecuci\u00f3n de un programa de forma inesperada. En lugar de que el programa se detenga abruptamente, las excepciones permiten capturar y gestionar estos errores de manera controlada. Esto es crucial para la robustez y seguridad de las aplicaciones.</p>"},{"location":"temas/03/3.2-prog-modular.html#32151-la-jerarquia-de-las-excepciones","title":"3.2.15.1 La jerarqu\u00eda de las excepciones","text":"<p>En la mayor\u00eda de los lenguajes, incluida nuestra versi\u00f3n de DAW, todas las excepciones se basan en una clase principal: la clase <code>Exception</code>. Esta es la base de la jerarqu\u00eda de excepciones y todas las excepciones que creamos o utilizamos, como <code>DivideByZeroException</code>, heredan de ella. Esto significa que un bloque <code>catch</code> que capture <code>Exception</code> puede manejar cualquier tipo de excepci\u00f3n.</p>"},{"location":"temas/03/3.2-prog-modular.html#32152-excepciones-requeridas-vs-no-requeridas","title":"3.2.15.2 Excepciones requeridas vs. no requeridas","text":"<p>En el mundo de la programaci\u00f3n, las excepciones se dividen en dos categor\u00edas principales:</p> <ol> <li>Excepciones requeridas (o <code>checked exceptions</code>): Son errores que el compilador te obliga a manejar. Se utilizan para condiciones previsibles y recuperables, como un archivo que no se encuentra o un problema de red. Si no las manejas, el c\u00f3digo no compilar\u00e1. Esto fomenta la creaci\u00f3n de c\u00f3digo robusto, pero puede llevar a una gran cantidad de bloques <code>try-catch</code>, lo que a veces dificulta la lectura del c\u00f3digo.</li> <li>Excepciones no requeridas (o <code>unchecked exceptions</code>): Son errores de los que el compilador no te obliga a ocuparte. Se utilizan para errores de programaci\u00f3n (como dividir por cero) o fallos inesperados del sistema. La idea es que son errores que el programa no puede recuperar y que deben ser corregidos por el desarrollador.</li> </ol> <p>En nuestro lenguaje DAW, las excepciones son no requeridas.</p> <ul> <li>Ventajas: El c\u00f3digo es m\u00e1s limpio, ya que no tienes que escribir bloques <code>try-catch</code> para cada posible error. Se puede centrar en la l\u00f3gica del negocio y manejar las excepciones solo donde es necesario.</li> <li>Inconvenientes: La responsabilidad de manejar las excepciones recae por completo en el desarrollador. Si no se manejan adecuadamente, el programa puede terminar abruptamente.</li> </ul>"},{"location":"temas/03/3.2-prog-modular.html#32153-bloques-try-catch-y-finally","title":"3.2.15.3 Bloques <code>try</code>, <code>catch</code> y <code>finally</code>","text":"<p>Para manejar excepciones, se usan los siguientes bloques de c\u00f3digo:</p> <ol> <li><code>try</code>: Contiene las sentencias que podr\u00edan generar una excepci\u00f3n. El programa \"intenta\" ejecutar este c\u00f3digo.</li> <li><code>catch</code>: Si una excepci\u00f3n ocurre en el bloque <code>try</code>, el control salta a este bloque para \"capturar\" y gestionar el error. 3.2.  <code>finally</code>: Un bloque opcional que se ejecuta siempre, tanto si se produce una excepci\u00f3n como si no. Es ideal para tareas de limpieza (cerrar archivos, conexiones). Es opcional.</li> </ol>"},{"location":"temas/03/3.2-prog-modular.html#32154-lanzar-excepciones-manualmente-throw","title":"3.2.15.4 Lanzar excepciones manualmente (<code>throw</code>)","text":"<p>La palabra clave <code>throw</code> te permite lanzar una excepci\u00f3n de forma expl\u00edcita. Esto es \u00fatil para errores de l\u00f3gica de negocio que t\u00fa mismo quieres definir, por ejemplo, que el divisor sea cero.</p> <p>Ejemplo 1: Funci\u00f3n que lanza una excepci\u00f3n si el divisor es cero.</p> <pre><code>function decimal dividirConThrow(int numerador, int divisor) {\n    if (divisor == 0) {\n        // Lanzamos una excepci\u00f3n de tipo DivideByZeroException\n        throw new DivideByZeroException(\"No se puede dividir por cero.\");\n    }\n    return (decimal)numerador / divisor;\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#32155-aserciones-assert","title":"3.2.15.5 Aserciones (<code>assert</code>)","text":"<p>Las aserciones son una herramienta de depuraci\u00f3n que verifica que una condici\u00f3n sea verdadera. Si la condici\u00f3n es falsa, se lanza una excepci\u00f3n de tipo <code>AssertionException</code>. Se usan para verificar supuestos sobre el estado del programa durante el desarrollo. No es recomendable dejar aserciones en el c\u00f3digo de producci\u00f3n, ya que est\u00e1n destinadas a detectar errores l\u00f3gicos durante la fase de desarrollo y prueba.</p> <p>Sintaxis en DAW: <code>assert(condici\u00f3n, \"mensaje de error opcional\");</code></p> <p>Ejemplo 2: Funci\u00f3n que usa una aserci\u00f3n para verificar el divisor.</p> <pre><code>function decimal dividirConAssert(int numerador, int divisor) {\n    // La aserci\u00f3n verifica que el divisor no sea cero.\n    // Si la condici\u00f3n es falsa, se lanza una 'AssertionException'.\n    assert(divisor != 0, \"El divisor no puede ser cero.\");\n\n    return (decimal)numerador / divisor;\n}\n</code></pre> <p>Ambas funciones pueden ser llamadas desde el bloque <code>Main</code> y sus excepciones pueden ser capturadas en los bloques <code>try-catch</code>.</p> <pre><code>Main {\n    var num = 10;\n    var div = 0;\n\n    // Consumimos la funci\u00f3n con `throw`\n    try {\n        System.out.println(\"Intentando dividir con 'throw'...\");\n        var resultadoThrow = dividirConThrow(num, div);\n        System.out.println(\"Resultado: \" + resultadoThrow);\n    } catch (DivideByZeroException e) { // &lt;-- Se captura un tipo de excepci\u00f3n espec\u00edfico\n        System.out.println(\"\u00a1Catch! Error capturado: \" + e.message);\n    } finally {\n        System.out.println(\"Fin del ejemplo 'throw'.\");\n    }\n\n    System.out.println(\"---\");\n\n    // Consumimos la funci\u00f3n con `assert`\n    try {\n        System.out.println(\"Intentando dividir con 'assert'...\");\n        var resultadoAssert = dividirConAssert(num, div);\n        System.out.println(\"Resultado: \" + resultadoAssert);\n    } catch (AssertionException e) { // &lt;-- Se captura un tipo de excepci\u00f3n espec\u00edfico\n        System.out.println(\"\u00a1Catch! Error de aserci\u00f3n capturado: \" + e.message);\n    } finally {\n        System.out.println(\"Fin del ejemplo 'assert'.\");\n    }\n}\n</code></pre> <p>El uso de excepciones y aserciones mejora la fiabilidad del programa, haciendo que la detecci\u00f3n y correcci\u00f3n de errores sea m\u00e1s sencilla, lo cual es vital para los procesos de depuraci\u00f3n y prueba.</p>"},{"location":"temas/03/3.2-prog-modular.html#32156-buenas-practicas-para-el-control-de-excepciones","title":"3.2.15.6 Buenas pr\u00e1cticas para el control de excepciones","text":"<ol> <li>Captura solo las excepciones que puedes manejar: No uses bloques <code>catch</code> gen\u00e9ricos que capturen todas las excepciones a menos que tengas una raz\u00f3n espec\u00edfica para hacerlo. Captura solo las excepciones que sabes c\u00f3mo manejar.</li> <li>Usa <code>finally</code> para limpieza: Si tienes recursos que deben ser liberados (como archivos o conexiones de red), usa el bloque <code>finally</code> para asegurarte de que siempre se liberen, independientemente de si ocurri\u00f3 una excepci\u00f3n o no. 3.2.  No abuses de las excepciones: Las excepciones deben usarse para manejar errores excepcionales, no para el flujo normal del programa. No uses excepciones para controlar la l\u00f3gica del programa.</li> <li>Proporciona informaci\u00f3n \u00fatil en las excepciones: Al lanzar excepciones, proporciona mensajes de error claros y \u00fatiles que ayuden a identificar la causa del problema. Esto facilitar\u00e1 la depuraci\u00f3n y el mantenimiento del c\u00f3digo.</li> </ol> <p>IMPORTANTE Imaginamos que vas a dividir dos n\u00fameros, pero el divisor puede ser cero. En lugar de dejar que el programa falle, puedes manejar la excepci\u00f3n y mostrar un mensaje amigable al usuario. \u00bfPor qu\u00e9 es malo que el programa falle sin control o simplemente dejar que falle? Porque el usuario no sabr\u00e1 qu\u00e9 ha pasado y el programa se cerrar\u00e1 abruptamente, perdiendo cualquier dato no guardado. Y aunque gestiones las excepciones, si no lo haces bien, puedes ocultar errores importantes que deber\u00edan ser corregidos, al final tu programa est\u00e1 fallando y puede que al levantarlo en la clausula catch no sepas qu\u00e9 ha pasado realmente o simplemente ignores el error y no haces nada, lo cual es peor o no lo hagas correctamente.</p> <pre><code>Main {\n    var num = 10;\n    var div = 0;\n\n    // aqu\u00ed usamos throw para lanzar una excepci\u00f3n si el divisor es cero\n    // Es la mejor manera de hacerlo? \n    try {\n        var resultado = dividirConThrow(num, div);\n        System.out.println(\"Resultado: \" + resultado);\n    } catch (DivideByZeroException e) {\n        System.out.println(\"Error: \" + e.message);\n        // Aqu\u00ed podr\u00edas manejar el error, por ejemplo, pedir otro divisor\n    } finally {\n        System.out.println(\"Fin del intento de divisi\u00f3n.\");\n    }\n\n    // aqu\u00ed el if es la manera recomendada de hacerlo\n    // Para qe dejar que el programe falle y se reobre si se puede evitar?\n    if (div != 0) {\n        var resultado = (decimal)num / div;\n        System.out.println(\"Resultado: \" + resultado);\n    } else {\n        System.out.println(\"No se puede dividir por cero.\");\n        // Aqu\u00ed podr\u00edas manejar el error, por ejemplo, pedir otro divisor\n    }\n\n\n}\n</code></pre>"},{"location":"temas/03/3.2-prog-modular.html#32157-resumen-del-control-de-excepciones","title":"3.2.15.7. Resumen del control de excepciones","text":"Concepto Clave Palabra Clave DAW Regla / Uso / Prop\u00f3sito Diferencia Clave / Impacto Bloque de Prueba <code>try</code> Contiene el c\u00f3digo que podr\u00eda generar una excepci\u00f3n (el c\u00f3digo \"arriesgado\"). El flujo normal del programa comienza aqu\u00ed. Si falla, salta a <code>catch</code>. Bloque de Captura <code>catch (Exception e)</code> Captura y gestiona el error (<code>e</code>). Permite recuperar el programa en lugar de que se detenga. Permite capturar la clase base <code>Exception</code> o tipos espec\u00edficos (ej. <code>DivideByZeroException</code>). Bloque de Limpieza <code>finally</code> Bloque opcional que se ejecuta SIEMPRE, haya o no excepci\u00f3n. Ideal para tareas de limpieza (cerrar archivos, liberar recursos). --- --- --- --- Lanzar Excepci\u00f3n <code>throw</code> Lanza una excepci\u00f3n manualmente (generalmente, una nueva) si se detecta una condici\u00f3n de error en la l\u00f3gica de negocio (ej. <code>if (divisor == 0) { throw ... }</code>). Se usa para indicar errores de l\u00f3gica que deben ser manejados por el c\u00f3digo llamante. Comprobaci\u00f3n L\u00f3gica <code>assert(condici\u00f3n)</code> Herramienta de depuraci\u00f3n. Verifica que una condici\u00f3n sea verdadera; si no lo es, lanza una <code>AssertionException</code>. No debe usarse en c\u00f3digo final (producci\u00f3n). Sirve para detectar errores l\u00f3gicos durante la fase de prueba. --- --- --- --- Jerarqu\u00eda Base <code>Exception</code> Clase padre de la que heredan todas las excepciones. Un <code>catch (Exception e)</code> captura cualquier error. Tipos de Excepci\u00f3n N/A En DAW, las excepciones son NO REQUERIDAS (<code>unchecked</code>). El compilador no te obliga a usar <code>try-catch</code>. La responsabilidad de manejar el error recae en el desarrollador. Mejor Pr\u00e1ctica <code>if</code> antes de <code>try-catch</code> Es mejor prevenir el error con un <code>if</code> (ej. <code>if (divisor != 0)</code>) antes que dejar que falle y usar <code>try-catch</code>. Las excepciones son para errores inesperados, no para validar el flujo normal del programa."}]}