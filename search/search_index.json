{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Inicio","text":""},{"location":"index.html#programacion","title":"Programaci\u00f3n","text":"<p>En este repositorio vamos a agrupar los materiales realizadas en el m\u00f3dulo 0485 de Programaci\u00f3n del CFGS de Desarrollo de Aplicaciones Web/Multiplataforma (DAM), cuyo curriculum viene fijado por el Real Decreto 686/2010 actualizado por el Real Decreto 405/2023 de 29 de mayo de 2023.</p> <p>//TODO: Actualizar enlace al RD cuando est\u00e9 disponible</p>"},{"location":"index.html#resultados-de-aprendizaje","title":"Resultados de Aprendizaje","text":"<p>Los diferentes resultados de aprendizaje (RA) trabajados junto con su peso aproximado, tal cual se indica en la programaci\u00f3n did\u00e1ctica, son:</p> C\u00f3digo Descripci\u00f3n Peso (%) RA1 Reconoce la estructura de un programa inform\u00e1tico. RA2 Escribe y prueba programas sencillos. RA3 Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje. RA4 Desarrolla programas organizados en clases RA5 Realiza operaciones de entrada y salida de informaci\u00f3n. RA6 Escribe programas que manipulen informaci\u00f3n. RA7 Utiliza bases de datos orientadas a objetos. RA7 Gestiona informaci\u00f3n almacenada en bases de datos relacionales.."},{"location":"temas/00/index.html","title":"Pseuc\u00f3digo, algoritmos y pensamiento computacional","text":""},{"location":"temas/00/index.html#pseucodigo-algoritmos-y-pensamiento-computacional","title":"Pseuc\u00f3digo, algoritmos y pensamiento computacional","text":""},{"location":"temas/01/index.html","title":"01 - Introducci\u00f3n a la programaci\u00f3n","text":""},{"location":"temas/01/index.html#01-introduccion-a-la-programacion-software","title":"01 - Introducci\u00f3n a la Programaci\u00f3n Software","text":""},{"location":"temas/01/index.html#1-fundamentos-de-la-programacion","title":"1. Fundamentos de la Programaci\u00f3n","text":""},{"location":"temas/01/index.html#11-que-es-programar","title":"1.1. \u00bfQu\u00e9 es Programar?","text":"<p>Programar es el proceso de crear software. Esta disciplina abarca desde la concepci\u00f3n inicial de una idea hasta que el programa est\u00e1 implementado y funcionando en un ordenador, enfoc\u00e1ndose en los principios y metodolog\u00edas para el desarrollo y mantenimiento de sistemas de software. Algunos autores consideran que el t\u00e9rmino \"desarrollo de software\" es m\u00e1s apropiado que \"ingenier\u00eda de software\".</p> <p>Definici\u00f3n de Programa Software</p> <p>Un programa software es la parte intangible o l\u00f3gica de un sistema inform\u00e1tico, un conjunto de programas que act\u00faan sobre el hardware para ejecutar las tareas deseadas por el usuario. Los programas son m\u00e9todos para resolver problemas, procesando informaci\u00f3n para obtener un resultado a partir de datos de entrada. Para que un programa comience a funcionar, sus instrucciones deben ser traducidas a un lenguaje que la m\u00e1quina entienda.</p> Proceso de Entrada, Proceso y Salida en un Programa <p>El Proceso de Desarrollo de Software</p> <p>El desarrollo de software implica una serie de etapas obligatorias para construir software fiable y de calidad. Estas fases se dividen en tres pasos gen\u00e9ricos: definici\u00f3n (qu\u00e9 desarrollar), desarrollo, y mantenimiento.</p> <p>Las fases principales del desarrollo de una aplicaci\u00f3n inform\u00e1tica son:</p> <ul> <li> <p>Fase de Resoluci\u00f3n del Problema:</p> <ul> <li>An\u00e1lisis: Requiere que el problema sea definido y comprendido claramente. Se establecen los objetivos, el alcance y se realiza un estudio de viabilidad y costes. Se identifican los requisitos funcionales (qu\u00e9 funciones realizar\u00e1 la aplicaci\u00f3n) y no funcionales (caracter\u00edsticas de calidad del sistema). Tambi\u00e9n implica analizar la documentaci\u00f3n, investigar y recopilar informaci\u00f3n \u00fatil. La culminaci\u00f3n es el Documento de Especificaci\u00f3n de Requisitos del Software (ERS), que act\u00faa como contrato entre cliente y desarrollador.</li> <li>Dise\u00f1o: Se define \"c\u00f3mo\" hacer la soluci\u00f3n. Se convierte la especificaci\u00f3n del an\u00e1lisis en un dise\u00f1o detallado, indicando el comportamiento o la secuencia l\u00f3gica de instrucciones que resuelvan el problema. Se descompone la aplicaci\u00f3n en operaciones m\u00e1s sencillas y se asignan a m\u00f3dulos. Incluye el dise\u00f1o arquitect\u00f3nico, dise\u00f1o detallado, dise\u00f1o de datos y de interfaz de usuario. Es crucial realizar una prueba o traza del programa para asegurar la soluci\u00f3n antes de la implementaci\u00f3n.</li> </ul> <p></p> </li> <li> <p>Fase de Implementaci\u00f3n:</p> <ul> <li>Codificaci\u00f3n o Construcci\u00f3n: Consiste en transformar o traducir los resultados obtenidos a un determinado lenguaje de programaci\u00f3n. Se escribe el c\u00f3digo fuente siguiendo las reglas gramaticales y la sintaxis del lenguaje. El c\u00f3digo debe ser modular, correcto, legible, eficiente y portable.</li> <li>Pruebas de Ejecuci\u00f3n y Validaci\u00f3n: Se implanta la aplicaci\u00f3n en el sistema y se verifica su funcionamiento. Se utilizan diferentes datos de prueba para ver si el programa responde a los requerimientos. Incluye pruebas unitarias, de integraci\u00f3n, funcionales, estructurales y beta testing.</li> <li>Documentaci\u00f3n: Es vital para el desarrollo y mantenimiento. Se distinguen la documentaci\u00f3n interna (comentarios en el c\u00f3digo fuente) y documentaci\u00f3n externa (manuales t\u00e9cnicos, de usuario, de instalaci\u00f3n, diagramas).</li> </ul> <p></p> </li> <li> <p>Fase de Explotaci\u00f3n y Mantenimiento:</p> <ul> <li>Explotaci\u00f3n (Despliegue): Los usuarios finales utilizan la aplicaci\u00f3n. Implica instalaci\u00f3n, puesta a punto y funcionamiento en el equipo del cliente.</li> <li>Mantenimiento: Peri\u00f3dicamente, se realizan evaluaciones y modificaciones para adaptar el programa a nuevas necesidades, corregir errores o actualizarlo.</li> <li>Retirada del Software: Ocurre cuando el software llega al final de su vida \u00fatil y no es rentable mantenerlo.</li> </ul> </li> </ul> <p>A lo largo de todo el proceso de desarrollo de software, se debe aplicar siempre un modelo de ciclo de vida. Estos modelos son la serie de pasos a seguir para desarrollar un programa.</p> Ciclo de Vida del Software"},{"location":"temas/01/index.html#12-algoritmos-la-receta-para-resolver-problemas","title":"1.2. Algoritmos: La Receta para Resolver Problemas \ud83c\udf73","text":"<p>Imagina que quieres hacer una tortilla de patatas. \u00bfQu\u00e9 haces? No empiezas a echar ingredientes al azar, \u00bfverdad? Sigues una serie de pasos ordenados: pelar y cortar las patatas, batir los huevos, fre\u00edr las patatas, mezclarlo todo y cuajar la tortilla.</p> <p>Pues bien, un algoritmo es exactamente eso: una secuencia de pasos finitos, claros y ordenados que nos llevan a la soluci\u00f3n de un problema o a la consecuci\u00f3n de una tarea.</p> <p>Los algoritmos est\u00e1n por todas partes en nuestra vida, no solo en la inform\u00e1tica.</p> <p>Concepto de Algoritmo y sus Caracter\u00edsticas</p> <p>Un algoritmo es una serie de pasos claros y ordenados que te permiten resolver un problema espec\u00edfico. No es un programa de computadora en s\u00ed mismo, sino la idea detr\u00e1s del programa. Piensa en \u00e9l como una receta de cocina: sin importar si la preparas en una estufa de gas, el\u00e9ctrica o de le\u00f1a, el resultado es el mismo porque la receta (el algoritmo) es independiente de la herramienta. Un algoritmo te dice qu\u00e9 hacer y en qu\u00e9 orden, sin importar la m\u00e1quina o el lenguaje de programaci\u00f3n.</p> <p>Ejemplos de Algoritmos de la Vida Cotidiana</p> <ul> <li> <p>Receta de cocina: Como hemos visto, una receta es un algoritmo perfecto. Te dice qu\u00e9 ingredientes necesitas (datos de entrada) y qu\u00e9 pasos seguir (proceso) para obtener un plato concreto (resultado).</p> </li> <li> <p>Montar un mueble de IKEA: Las instrucciones son un algoritmo. Si te saltas un paso o lo haces en el orden incorrecto, lo m\u00e1s probable es que el mueble no quede bien.</p> </li> <li> <p>Seguir una ruta en Google Maps: Le dices a d\u00f3nde quieres ir (problema), y la aplicaci\u00f3n calcula una serie de instrucciones paso a paso (\"gira a la derecha en 200 metros\", \"contin\u00faa recto\"...) para que llegues a tu destino (soluci\u00f3n).</p> </li> <li> <p>Sacar dinero de un cajero:</p> <ol> <li>Introducir tarjeta.</li> <li>Teclear el PIN.</li> <li>Seleccionar \"Sacar dinero\".</li> <li>Elegir la cantidad.</li> <li>Recoger el dinero.</li> <li>Recoger la tarjeta.</li> <li>Finalizar.</li> </ol> </li> </ul> <p>En programaci\u00f3n, antes de escribir una sola l\u00ednea de c\u00f3digo, primero pensamos en el algoritmo que resolver\u00e1 nuestro problema</p>"},{"location":"temas/01/index.html#121-caracteristicas-esenciales","title":"1.2.1. Caracter\u00edsticas Esenciales","text":"<p>Para que un algoritmo sea considerado de calidad, debe cumplir con las siguientes caracter\u00edsticas:</p> <ul> <li>Finito: Siempre debe terminar en un n\u00famero limitado de pasos. No puede ser un proceso infinito.</li> <li>Preciso: Cada paso debe ser claro y no dar lugar a ambig\u00fcedades.</li> <li>Definido: Si usas los mismos datos de entrada, el algoritmo siempre debe producir el mismo resultado.</li> <li>Eficiente: Debe utilizar la menor cantidad de recursos (tiempo y memoria) posible.</li> <li>General: Debe servir para resolver una clase de problemas, no solo un caso particular.</li> <li>Correcto: Debe resolver el problema para el cual fue dise\u00f1ado.</li> </ul> <p>Adem\u00e1s de estas caracter\u00edsticas fundamentales, un buen algoritmo debe ser comprensible, modificable y reutilizable, lo que facilita su uso y mantenimiento a lo largo del tiempo. Para lograrlo, es crucial que est\u00e9 bien estructurado y documentado con comentarios. Finalmente, todo algoritmo debe ser probado para asegurar que funciona correctamente en todos los casos posibles.</p> Diagrama de flujo de un algoritmo <p>Reglas para el Dise\u00f1o de Algoritmos (Abstracci\u00f3n, Modularidad)</p> <p>Para dise\u00f1ar soluciones correctas y eficientes, se deben considerar los siguientes conceptos: 1.  Abstracci\u00f3n: Realizar un an\u00e1lisis del problema para descomponerlo en problemas m\u00e1s peque\u00f1os y de menor complejidad, describiendo cada uno de manera precisa. 2.  Divide y vencer\u00e1s: Una filosof\u00eda general para resolver problemas, central en el enfoque de abstracci\u00f3n y modularidad. 3.  Encapsulaci\u00f3n: Ocultar la informaci\u00f3n para poder implementarla de diferentes maneras sin que esto influya en el resto de elementos. 4.  Modularidad: Estructurar cada parte en m\u00f3dulos independientes, donde cada uno tendr\u00e1 su funci\u00f3n correspondiente. El dise\u00f1o modular (top-down design) descompone un problema en subproblemas m\u00e1s sencillos.</p> <p>Para representar los algoritmos gr\u00e1ficamente, se pueden usar herramientas como diagramas de flujo (que usan s\u00edmbolos gr\u00e1ficos y se utilizan en fases de an\u00e1lisis) y pseudoc\u00f3digo (basado en palabras clave en lenguaje natural y es la t\u00e9cnica m\u00e1s utilizada).</p>"},{"location":"temas/01/index.html#122-diferencia-entre-algoritmo-y-programa","title":"1.2.2. Diferencia entre Algoritmo y Programa","text":"<p>La diferencia fundamental entre algoritmo y programa radica en que el algoritmo es una descripci\u00f3n de los pasos para resolver un problema de forma gen\u00e9rica e independiente de la m\u00e1quina y del lenguaje de programaci\u00f3n. En cambio, el programa consiste en esos mismos pasos, pero escritos en un lenguaje de programaci\u00f3n espec\u00edfico para que puedan ser ejecutados en un ordenador y obtener la soluci\u00f3n. Los lenguajes de programaci\u00f3n son solo un medio para expresar el algoritmo, y el ordenador es el procesador para ejecutarlo.</p> <p>Tabla 1: Comparaci\u00f3n entre Algoritmo y Programa</p> Caracter\u00edstica Algoritmo Programa Nivel de Abstracci\u00f3n Gen\u00e9rico, independiente de la m\u00e1quina y el lenguaje. Espec\u00edfico, escrito en un lenguaje de programaci\u00f3n. Formato Secuencia de pasos l\u00f3gicos, pseudoc\u00f3digo, diagramas de flujo. C\u00f3digo fuente, instrucciones en un lenguaje concreto. Ejecuci\u00f3n No ejecutable directamente por una m\u00e1quina. Ejecutable por un ordenador despu\u00e9s de ser traducido. Objetivo Describir la soluci\u00f3n a un problema. Implementar la soluci\u00f3n para que una m\u00e1quina la ejecute."},{"location":"temas/01/index.html#2-lenguajes-de-programacion","title":"2. Lenguajes de Programaci\u00f3n","text":""},{"location":"temas/01/index.html#21-conceptos-fundamentales-del-lenguaje","title":"2.1. Conceptos Fundamentales del Lenguaje","text":"<p>Un lenguaje de programaci\u00f3n es un idioma artificial, un conjunto de reglas sint\u00e1cticas y sem\u00e1nticas, s\u00edmbolos y palabras especiales establecidas para la construcci\u00f3n de programas. Estos elementos permiten al programador escribir secuencias de comandos para que una m\u00e1quina realice un comportamiento deseado.</p> <p>Los elementos que componen un lenguaje de programaci\u00f3n son:</p> <ul> <li>L\u00e9xico (Alfabeto): Es el conjunto finito de s\u00edmbolos permitidos y palabras especiales, el vocabulario del lenguaje: letras, d\u00edgitos, operadores, signos de puntuaci\u00f3n y palabras reservadas. Estos s\u00edmbolos se combinan para formar los elementos b\u00e1sicos del lenguaje, como identificadores, literales y operadores. Ejemplos de l\u00e9xico son: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>;</code>, <code>{}</code>, <code>()</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>int</code>, <code>decimal</code>, <code>string</code>, <code>bool</code>, etc.</li> <li>Sintaxis: Son las normas de construcci\u00f3n que rigen la estructura de las declaraciones y expresiones v\u00e1lidas en el lenguaje. Se refiere a las posibles combinaciones de los s\u00edmbolos y palabras especiales. Define c\u00f3mo se deben organizar los elementos l\u00e9xicos para formar sentencias correctas. Por ejemplo, en muchos lenguajes, una sentencia de asignaci\u00f3n debe seguir la estructura <code>identificador = expresi\u00f3n;</code>. La sintaxis es crucial para que el compilador o int\u00e9rprete pueda entender y procesar el c\u00f3digo correctamente. Ejemplo de una sentencia sint\u00e1cticamente correcta: <code>int numero = 10;</code>.</li> <li>Sem\u00e1ntica: Es el significado de las construcciones y define las acciones que se llevar\u00e1n a cabo con las combinaciones de los s\u00edmbolos. Es importante tener en cuenta que pueden existir sentencias sint\u00e1cticamente correctas, pero sem\u00e1nticamente incorrectas. Por ejemplo, la sentencia <code>int numero = \"texto\";</code> es sint\u00e1cticamente correcta, pero sem\u00e1nticamente incorrecta porque intenta asignar un valor de tipo cadena a una variable de tipo entero. La sem\u00e1ntica asegura que las operaciones y combinaciones de elementos tengan sentido dentro del contexto del lenguaje y el problema que se est\u00e1 resolviendo.</li> </ul>"},{"location":"temas/01/index.html#22-paradigmas-de-programacion","title":"2.2. Paradigmas de Programaci\u00f3n","text":"<p>Un paradigma de programaci\u00f3n es un modelo fundamental o una filosof\u00eda para el dise\u00f1o y la implementaci\u00f3n de programas. Este modelo determina c\u00f3mo ser\u00e1 el proceso de dise\u00f1o y la estructura final del c\u00f3digo. Son como las \"reglas del juego\" que gu\u00edan c\u00f3mo se aborda la soluci\u00f3n de un problema. El objetivo es reducir la dificultad para el mantenimiento, mejorar el rendimiento del programador y, en general, mejorar la productividad y calidad de los programas.</p> <p>Tipos de Paradigmas</p> <p>Existen diversos paradigmas, y muchos lenguajes modernos son multiparadigma, combinando caracter\u00edsticas de varios para ofrecer flexibilidad (ej. Python, JavaScript, Java, Kotlin, C#).</p> <ul> <li>Programaci\u00f3n Imperativa/Estructurada: Se basa en una serie de comandos que la computadora ejecuta en orden para cambiar el estado del programa. Utiliza estructuras como sentencias secuenciales, selectivas (condicionales) y repetitivas (bucles). Ejemplos incluyen C y Pascal.</li> <li>Programaci\u00f3n Procedimental: Un subtipo del paradigma imperativo. Los programas se organizan en procedimientos (o funciones) que manipulan el estado global del programa, buscando la modularidad. Ejemplos incluyen C, Pascal y BASIC.</li> <li>Programaci\u00f3n Orientada a Objetos (POO): Es el paradigma m\u00e1s utilizado. Los programas se construyen como una colecci\u00f3n de objetos que interact\u00faan entre s\u00ed. Un objeto es una instancia de una clase que contiene datos (atributos) y m\u00e9todos para operar sobre ellos. La POO promueve la reutilizaci\u00f3n de c\u00f3digo, depuraci\u00f3n m\u00e1s sencilla y mejor mantenimiento, bas\u00e1ndose en pilares como el polimorfismo, la herencia y la encapsulaci\u00f3n. Ejemplos: C++, Python, Kotlin, C#. Java es un lenguaje totalmente orientado a objetos.</li> <li>Programaci\u00f3n Declarativa: Los programas describen el resultado deseado, no el proceso paso a paso para lograrlo. Suelen ser lenguajes interpretados.<ul> <li>L\u00f3gica: Utiliza reglas y afirmaciones de l\u00f3gica formal para que la computadora deduzca la respuesta, muy usada en inteligencia artificial. Ejemplo: Prolog.</li> <li>Funcional: Se enfoca en el uso de funciones matem\u00e1ticas que no cambian el estado ni los datos externos, promoviendo c\u00f3digo modular y estructurado. Ejemplos: Lisp, Haskell, Scala.</li> </ul> </li> <li>Programaci\u00f3n de Eventos: El flujo del programa es impulsado por eventos (clics, movimientos del rat\u00f3n, etc.). Com\u00fan en interfaces gr\u00e1ficas de usuario (GUI) y servidores.</li> <li>Programaci\u00f3n Reactiva: Un subtipo de la programaci\u00f3n de eventos que gestiona flujos de datos asincr\u00f3nicos y la propagaci\u00f3n de cambios, ideal para aplicaciones en tiempo real.</li> <li>Programaci\u00f3n Multiparadigma: Lenguajes que admiten y combinan m\u00faltiples paradigmas, permitiendo elegir el mejor enfoque para cada parte del problema. Ejemplos: C++, JavaScript, Python, Kotlin, C#.</li> </ul>"},{"location":"temas/01/index.html#23-clasificacion-de-lenguajes-de-programacion","title":"2.3. Clasificaci\u00f3n de Lenguajes de Programaci\u00f3n","text":"<p>Los lenguajes de programaci\u00f3n pueden ser clasificados en funci\u00f3n de lo cerca que est\u00e9n del lenguaje humano o del lenguaje de los computadores.</p> <p>Seg\u00fan su cercan\u00eda al lenguaje humano (Nivel de Abstracci\u00f3n)</p> Lenguajes de Bajo NivelLenguajes de Bajo MedioLenguajes de Alto Nivel <p>Totalmente dependientes de la m\u00e1quina; un programa no puede migrarse a otras m\u00e1quinas. Aprovechan al m\u00e1ximo las caracter\u00edsticas del hardware.</p> <ul> <li> <p>Lenguaje M\u00e1quina: Instrucciones en combinaciones de unos y ceros (c\u00f3digo binario). Es el \u00fanico lenguaje que el ordenador entiende directamente (no necesita traducci\u00f3n). Fue el primer lenguaje, \u00fanico para cada procesador (no portable), r\u00e1pido pero dif\u00edcil de manejar y depurar.</p> Operaci\u00f3n Lenguaje m\u00e1quina Decimal SUMAR 00101101 45 RESTAR 00010011 19 MOVER 00111010 58 </li> <li> <p>Lenguaje Ensamblador: Sustituy\u00f3 al lenguaje m\u00e1quina, utilizando mnemot\u00e9cnicos (c\u00f3digos de operaci\u00f3n) en lugar de binarios. Necesita un programa ensamblador que lo traduzca a lenguaje m\u00e1quina para ejecutarse. Aunque m\u00e1s legible, sigue siendo de bajo nivel, dependiente del hardware y dif\u00edcil de usar, interpretar y modificar.</p> Operaci\u00f3n Mnemot\u00e9cnico MULTIPLICAR MUL DIVIDIR DIV MOVER MOV </li> </ul> <p>Lenguajes de Medio Nivel: T\u00e9rmino no universalmente aceptado, se refiere a lenguajes como C que pueden acceder a registros del sistema y direcciones de memoria (caracter\u00edsticas de bajo nivel) mientras realizan operaciones de alto nivel.   </p> <p>Lenguajes de Alto Nivel: Cercanos al lenguaje natural (ingl\u00e9s), independientes de la arquitectura del ordenador. Permiten al programador abstraerse del funcionamiento interno de la m\u00e1quina. Utilizan sentencias y \u00f3rdenes derivadas del idioma ingl\u00e9s. Necesitan un traductor para ser entendidos por la m\u00e1quina. Incorporan librer\u00edas, funciones predeterminadas y suelen ofrecer frameworks. La mayor\u00eda de los lenguajes actuales se engloban aqu\u00ed. Ejemplos: C++, Java, Python, JavaScript, PHP.</p> <p></p>"},{"location":"temas/01/index.html#232-segun-su-mecanismo-de-traduccion-compilados-interpretados-mixtos","title":"2.3.2. Seg\u00fan su mecanismo de traducci\u00f3n (Compilados, Interpretados, Mixtos)","text":"<p>Los programas se traducen a c\u00f3digo binario ejecutable mediante compilaci\u00f3n o interpretaci\u00f3n.</p> <ul> <li> <p>Lenguajes Compilados: Necesitan un compilador que traduce el c\u00f3digo fuente completo a c\u00f3digo objeto (o c\u00f3digo m\u00e1quina) en un solo paso, antes de la ejecuci\u00f3n. La ejecuci\u00f3n es eficiente. Requieren un enlazador para unir el c\u00f3digo objeto con librer\u00edas. El c\u00f3digo es m\u00e1s seguro, ya que el c\u00f3digo fuente no es directamente accesible. Ejemplos: C y C++.</p> <p>Un compilador realiza varias fases: 1.  An\u00e1lisis L\u00e9xico: Agrupa el c\u00f3digo fuente en tokens. 2.  An\u00e1lisis Sint\u00e1ctico: Comprueba la estructura gramatical y genera un \u00e1rbol sint\u00e1ctico. 3.  An\u00e1lisis Sem\u00e1ntico: Verifica la l\u00f3gica y compatibilidad de tipos. 4.  Generaci\u00f3n de C\u00f3digo Intermedio: Un c\u00f3digo de bajo nivel independiente de la arquitectura. 5.  Optimizaci\u00f3n de C\u00f3digo: Mejora el c\u00f3digo para mayor eficiencia. 6.  Generaci\u00f3n de C\u00f3digo Objeto: Convierte el c\u00f3digo a lenguaje m\u00e1quina espec\u00edfico. 7.  Enlazador (Linker): Une el c\u00f3digo objeto con librer\u00edas.</p> </li> <li> <p>Lenguajes Interpretados: No generan c\u00f3digo objeto. Un int\u00e9rprete lee y ejecuta el c\u00f3digo fuente l\u00ednea a l\u00ednea, o instrucci\u00f3n por instrucci\u00f3n, en el momento. Son menos eficientes en ejecuci\u00f3n que los compilados, ya que se traducen en tiempo de ejecuci\u00f3n. Requieren que el int\u00e9rprete est\u00e9 cargado en memoria. El c\u00f3digo fuente es legible, lo que puede comprometer la seguridad. Ejemplos: Perl, PHP, Python, JavaScript.</p> </li> <li> <p>Lenguajes Mixtos o Virtuales (Intermediarios): Combinan caracter\u00edsticas de ambos. El c\u00f3digo fuente se compila a un c\u00f3digo binario intermedio (no ejecutable) llamado bytecode. Este bytecode es luego interpretado por una m\u00e1quina virtual para ejecutarlo en cualquier plataforma compatible. Son m\u00e1s portables, buscando \"compilar una vez y ejecutar en cualquier sistema\". Java y C# son ejemplos clave de lenguajes mixtos.</p> </li> </ul> Diferencias entre lenguajes compilados, interpretados y mixtos"},{"location":"temas/01/index.html#233-segun-su-sistema-de-tipos-rigidez-momento-de-verificacion-declaracion-sin-tipado","title":"2.3.3. Seg\u00fan su sistema de tipos (Rigidez, Momento de Verificaci\u00f3n, Declaraci\u00f3n, Sin Tipado)","text":"<p>Un tipo de dato es una clasificaci\u00f3n que define el conjunto de valores que una variable puede tomar y las operaciones v\u00e1lidas que se pueden realizar sobre esos valores. Esta clasificaci\u00f3n es fundamental porque determina la cantidad de memoria que el sistema operativo debe reservar para la variable.</p> <p>El sistema de tipos de un lenguaje de programaci\u00f3n es un conjunto de reglas que definen c\u00f3mo se manejan y verifican estos tipos de datos.</p> <p>Sistemas de Tipado</p> <ul> <li>Rigidez (Tipado Fuerte vs. Tipado D\u00e9bil):<ul> <li>Tipado Fuerte: Requiere que los tipos de datos sean compatibles para realizar operaciones, evitando conversiones autom\u00e1ticas o \"impl\u00edcitas\" entre tipos no relacionados. Esto previene errores inesperados y hace el c\u00f3digo m\u00e1s robusto. Ejemplos: Python, Java, C#, Ruby.</li> <li>Tipado D\u00e9bil: Permite conversiones de tipo autom\u00e1ticas, lo que puede llevar a errores dif\u00edciles de detectar. Ejemplos: JavaScript, PHP, VBScript.</li> </ul> </li> <li>Momento de Verificaci\u00f3n (Tipado Est\u00e1tico vs. Tipado Din\u00e1mico):<ul> <li>Tipado Est\u00e1tico: La verificaci\u00f3n de tipos se realiza en tiempo de compilaci\u00f3n. El tipo de cada variable debe ser conocido y, a menudo, declarado expl\u00edcitamente antes de ejecutar el programa. Si hay un error de tipo, el programa no compilar\u00e1. Garantiza mayor seguridad y rendimiento. Ejemplos: C++, Java, C#, Swift.</li> <li>Tipado Din\u00e1mico: La verificaci\u00f3n de tipos se realiza en tiempo de ejecuci\u00f3n. No es necesario declarar el tipo de una variable expl\u00edcitamente; el int\u00e9rprete lo determina autom\u00e1ticamente. Una misma variable puede cambiar de tipo durante la ejecuci\u00f3n. Ofrece flexibilidad, pero los errores de tipo solo se descubren en ejecuci\u00f3n. Ejemplos: Python, JavaScript, Ruby, PHP.</li> </ul> </li> <li>Declaraci\u00f3n (Tipado Expl\u00edcito vs. Impl\u00edcito - Inferencia):<ul> <li>Tipado Expl\u00edcito: El programador debe declarar manualmente el tipo de cada variable. Ejemplo en C++: <code>int numero = 10;</code>.</li> <li>Tipado Impl\u00edcito (Inferencia de Tipos): El compilador o int\u00e9rprete deduce el tipo de la variable a partir del valor asignado, sin que el programador tenga que declararlo. Esto hace el c\u00f3digo m\u00e1s conciso y r\u00e1pido de escribir. Ejemplo en Python: <code>numero = 10;</code>.</li> </ul> </li> <li>Lenguajes sin Tipado (Tipado Nulo): En lenguajes de muy bajo nivel, como el ensamblador, no existe un sistema de tipos formal. Las variables se manejan como secuencias de bits, y es responsabilidad del programador interpretar los datos.</li> </ul> <p> </p> <p>Tabla: Clasificaci\u00f3n de Lenguajes seg\u00fan su Sistema de Tipado</p> Sistema de Tipado Descripci\u00f3n Ejemplos de Lenguajes Est\u00e1tico y Fuerte Tipos verificados en compilaci\u00f3n; no hay conversiones impl\u00edcitas. C++, Java, C# Din\u00e1mico y Fuerte Tipos verificados en ejecuci\u00f3n; no hay conversiones impl\u00edcitas. Python, Ruby Est\u00e1tico y D\u00e9bil Tipos verificados en compilaci\u00f3n; s\u00ed hay conversiones impl\u00edcitas. C, VBScript (algunos) Din\u00e1mico y D\u00e9bil Tipos verificados en ejecuci\u00f3n; s\u00ed hay conversiones impl\u00edcitas. JavaScript, PHP"},{"location":"temas/01/index.html#234-segun-generaciones","title":"2.3.4. Seg\u00fan Generaciones","text":"<p>La evoluci\u00f3n de los lenguajes de programaci\u00f3n se puede dividir en 5 etapas o generaciones:</p> <ul> <li>Primera Generaci\u00f3n: Lenguaje m\u00e1quina.</li> <li>Segunda Generaci\u00f3n: Creaci\u00f3n de los primeros lenguajes ensambladores.</li> <li>Tercera Generaci\u00f3n: Creaci\u00f3n de los primeros lenguajes de alto nivel (C, Pascal, Cobol).</li> <li>Cuarta Generaci\u00f3n: Lenguajes capaces de generar c\u00f3digo por s\u00ed solos (RAD), con los cuales se pueden realizar aplicaciones sin ser experto. Incluyen lenguajes orientados a objetos, permitiendo la reutilizaci\u00f3n de c\u00f3digo. Suelen tener acceso a bases de datos, capacidades gr\u00e1ficas y generaci\u00f3n de c\u00f3digo autom\u00e1tica. Ej. Visual Studio, IntelliJ.</li> <li>Quinta Generaci\u00f3n: Lenguajes orientados a la inteligencia artificial (LISP).</li> </ul> <p></p>"},{"location":"temas/01/index.html#3-elementos-fundamentales-en-la-programacion","title":"3. Elementos Fundamentales en la Programaci\u00f3n","text":""},{"location":"temas/01/index.html#31-estructura-y-bloques-fundamentales-de-un-programa","title":"3.1. Estructura y Bloques Fundamentales de un Programa","text":"<p>Para escribir programas, es importante seguir una estructura definida que facilite su comprensi\u00f3n y mantenimiento. A lo largo de este tema usaremos el pseudoc\u00f3digo especial o lenguaje de DAW. Este lenguaje de nuestro curso es estructurado, similar a C# y Java, pero con una sintaxis simplificada y adaptada para el aprendizaje.</p> <p></p> <p>Estructura General de un Programa (Funci\u00f3n Principal <code>Main()</code>)</p> <p>Un programa se organiza alrededor de una bloque principal que sirve como punto de entrada para su ejecuci\u00f3n. Este bloque se denomina <code>Main()</code> en el lenguaje DAW. Todo programa debe tener este bloque principal, que contiene las instrucciones que se ejecutan al iniciar el programa. Es decir, la l\u00f3gica del programa y/o algoritmo se escribe dentro de este bloque.</p> <pre><code>// Mi primer programa en pseudoc\u00f3digo DAW\nMain() {\n  // Aqu\u00ed se escribir\u00e1 el c\u00f3digo principal del programa\n  writeLine(\"\u00a1Hola, mundo de la programaci\u00f3n!\");\n}\n</code></pre> <p>Reglas de Sintaxis B\u00e1sicas (Bloques de C\u00f3digo <code>{ }</code>, Punto y Coma <code>;</code>)</p> <ul> <li>Bloques de c\u00f3digo <code>{ }</code>: Son conjuntos de instrucciones que se agrupan, marcadas por la apertura y cierre de llaves. El c\u00f3digo dentro de ellas es considerado interno al bloque.</li> <li>Punto y coma <code>;</code>: Cada instrucci\u00f3n o sentencia (que no sea un bloque de c\u00f3digo o una declaraci\u00f3n de bloque) debe finalizar con un punto y coma. Su omisi\u00f3n resulta en errores sint\u00e1cticos.</li> <li>Comentarios <code>//</code> y <code>/* */</code>: Se utilizan para agregar notas explicativas al c\u00f3digo. Los comentarios de una l\u00ednea comienzan con <code>//</code>, mientras que los de varias l\u00edneas se encierran entre <code>/*</code> y <code>*/</code>.</li> <li>Espacios en blanco: Se pueden usar espacios en blanco y tabulaciones para mejorar la legibilidad del c\u00f3digo. No afectan la ejecuci\u00f3n, pero es importante ser consistente. Es obligatorio usar tabulaciones o espacios para la indentaci\u00f3n del c\u00f3digo dentro de bloques. Se recomienda usar 4 espacios por nivel de indentaci\u00f3n.</li> <li>Saltos de l\u00ednea: Se pueden usar para separar instrucciones y mejorar la legibilidad. Cada instrucci\u00f3n debe estar en una l\u00ednea separada.</li> <li>Identaci\u00f3n: Es la pr\u00e1ctica de alinear el c\u00f3digo dentro de bloques para reflejar su estructura jer\u00e1rquica. Mejora la legibilidad y facilita la comprensi\u00f3n del flujo del programa.</li> </ul> <pre><code>// Ejemplo de indentaci\u00f3n correcta\nMain() {\n  writeLine(\"Inicio del programa\");\n  if (true) {\n      writeLine(\"Condici\u00f3n verdadera\");\n  } else {\n      writeLine(\"Condici\u00f3n falsa\");\n  }\n  writeLine(\"Fin del programa\");\n}\n</code></pre> <p>Sensibilidad a May\u00fasculas y Min\u00fasculas</p> <p>El pseudoc\u00f3digo, al igual que muchos lenguajes de programaci\u00f3n reales, es sensible a may\u00fasculas y min\u00fasculas. Esto significa que <code>variable</code> y <code>Variable</code> ser\u00edan consideradas dos elementos distintos. Es una buena pr\u00e1ctica mantener una convenci\u00f3n de nomenclatura consistente.</p> <pre><code>Main() {\n  int numero = 10; // Variable en min\u00fasculas\n  int Numero = 20; // Variable en may\u00fascula, diferente de 'numero'\n  writeLine(numero); // Imprime 10\n  writeLine(Numero); // Imprime 20\n}\n</code></pre>"},{"location":"temas/01/index.html#32-tipos-de-datos-basicos","title":"3.2. Tipos de Datos B\u00e1sicos","text":""},{"location":"temas/01/index.html#321-concepto-de-tipo-de-dato-valores-validos-operaciones-y-espacio-en-memoria","title":"3.2.1. Concepto de Tipo de Dato: Valores v\u00e1lidos, operaciones y espacio en memoria**","text":"<p>Un tipo de dato es una clasificaci\u00f3n fundamental que especifica: *   El conjunto de valores v\u00e1lidos que una variable puede tomar. *   Las operaciones permitidas sobre esos valores. *   La cantidad de memoria que el sistema operativo debe reservar para la variable.</p> <p>En un lenguaje fuertemente tipado, como el que se simula, a todo dato se le asigna un tipo que se conoce antes de la ejecuci\u00f3n del programa, y el lenguaje controla exhaustivamente la compatibilidad de tipos. esto ayuda a prevenir errores y garantiza que las operaciones se realicen de manera segura y predecible. En lenguajes de tipado din\u00e1mico, los tipos se determinan en tiempo de ejecuci\u00f3n, lo que ofrece mayor flexibilidad pero puede introducir errores si no se manejan adecuadamente.</p>"},{"location":"temas/01/index.html#322-tipos-de-datos-comunes-y-su-uso-de-memoria","title":"3.2.2. Tipos de Datos Comunes (y su uso de memoria)","text":"<p>Los tipos de datos que m\u00e1s utilizaremos en el pseudoc\u00f3digo son <code>int</code>, <code>decimal</code>, <code>string</code> y <code>bool</code>.</p> <ul> <li>Enteros (<code>int</code>):<ul> <li>Almacena n\u00fameros enteros (sin decimales), positivos y negativos.</li> <li>Valores: Un rango amplio, por ejemplo, de aproximadamente -2.147.483.648 a 2.147.483.647. Se utilizan para contar o en operaciones matem\u00e1ticas sin fracciones.</li> <li>Uso de memoria: Generalmente ocupan 32 bits (4 bytes) en la mayor\u00eda de los sistemas.</li> </ul> </li> <li>Reales (<code>decimal</code>):<ul> <li>Almacena n\u00fameros con decimales. Se usan para operaciones financieras o cient\u00edficas.</li> <li>Valores: Con alta precisi\u00f3n (hasta 15 o 16 d\u00edgitos decimales). Los n\u00fameros reales se representan de forma aproximada en un ordenador debido a su capacidad finita de almacenamiento.</li> <li>Uso de memoria: Generalmente ocupan 64 bits (8 bytes).</li> </ul> </li> <li>Cadenas (<code>string</code>):<ul> <li>Almacena una secuencia de caracteres. Se utiliza para texto, nombres, frases.</li> <li>Valores: Cualquier texto entre comillas dobles.</li> <li>Uso de memoria: Las cadenas son tipos de referencia, lo que significa que su tama\u00f1o var\u00eda seg\u00fan la longitud de la cadena, ya que almacenan una direcci\u00f3n de memoria a la cadena real.</li> </ul> </li> <li>Booleanos (<code>bool</code>):<ul> <li>Almacena un valor l\u00f3gico. Se utiliza para condiciones de verdadero o falso.</li> <li>Valores: Solo <code>true</code> o <code>false</code>.</li> <li>Uso de memoria: Generalmente ocupan 1 bit, pero suelen almacenarse en un byte para eficiencia.</li> </ul> </li> </ul> <p>Tabla 5: Tipos de Datos B\u00e1sicos, Valores y Uso de Memoria</p> Tipo de Dato Descripci\u00f3n Rango/Valores Comunes Uso de Memoria (T\u00edpico) <code>int</code> N\u00fameros enteros \u00b1 2 mil millones (aprox. 32 bits) 4 bytes (32 bits) <code>decimal</code> N\u00fameros con decimales \u00b1 1.7E+308 (aprox. 64 bits) 8 bytes (64 bits) <code>string</code> Secuencia de caracteres Texto entre comillas dobles Variable (tipo referencia) <code>bool</code> Valores l\u00f3gicos <code>true</code>, <code>false</code> 1 byte (para 1 bit)"},{"location":"temas/01/index.html#323-tipos-de-datos-enumerados-enum","title":"3.2.3. Tipos de Datos Enumerados (<code>enum</code>)","text":"<p>Los tipos enumerados (<code>enum</code>) permiten definir un nuevo tipo cuyos valores posibles son un conjunto de nombres simb\u00f3licos predefinidos. Son \u00fatiles para representar un conjunto fijo de constantes con significado. Para declararlos se usa la palabra reservada <code>enum</code>, seguida del nombre del <code>enum</code> y la lista de valores que puede tomar entre llaves <code>{}</code>. Los valores se consideran constantes, van separados por comas y deben ser \u00fanicos.</p> <p></p><pre><code>enum Dias { LUNES, MARTES, MIERCOLES, JUEVES, VIERNES, SABADO, DOMINGO };\n\nMain() {\n  Dias diaActual = Dias.MARTES;\n  Dias diaSiguiente = Dias.MIERCOLES;\n\n  writeLine(\"Hoy es: \" + diaActual);\n  writeLine(\"Ma\u00f1ana es: \" + diaSiguiente);\n}\n</code></pre> El <code>enum</code> permite definir un nuevo tipo cuyos valores posibles son los que nosotros definamos.<p></p>"},{"location":"temas/01/index.html#324-control-de-nulos-null-en-tipos-de-datos-operador-para-tipos-de-valor","title":"3.2.4. Control de Nulos (<code>null</code>) en Tipos de Datos (operador <code>?</code> para tipos de valor)","text":"<p>En muchos lenguajes de programaci\u00f3n, incluido el pseudoc\u00f3digo que estamos utilizando, es importante manejar la posibilidad de que una variable no tenga un valor asignado, es decir, que sea <code>null</code>. Esto es especialmente relevante para evitar errores en tiempo de ejecuci\u00f3n cuando se intenta acceder a una variable que no ha sido inicializada. Null implica que la variable no apunta a ning\u00fan valor v\u00e1lido en memoria.</p> <ul> <li>Los tipos de valor (como <code>int</code>, <code>decimal</code>, <code>bool</code>) no pueden ser <code>null</code> por defecto. Para permitir que almacenen la ausencia de valor (nulo), se les puede a\u00f1adir el s\u00edmbolo <code>?</code>.</li> <li>Los tipos de referencia (como <code>string</code>) pueden ser <code>null</code> por defecto.</li> </ul> <pre><code>Main() {\n  int? numeroNulo = null; // Un entero que puede ser nulo\n  string textoOpcional = null; // Una cadena que puede ser nula\n\n  if (numeroNulo == null) {\n      writeLine(\"NumeroNulo es nulo.\");\n  }\n\n  if (textoOpcional == null) {\n      writeLine(\"TextoOpcional es nulo.\");\n  }\n}\n</code></pre>"},{"location":"temas/01/index.html#33-variables-constantes-y-literales","title":"3.3. Variables, Constantes y Literales","text":""},{"location":"temas/01/index.html#331-identificadores-y-palabras-reservadas","title":"3.3.1. Identificadores y Palabras Reservadas","text":"<ul> <li> <p>Identificadores: Son los nombres que se les dan a las variables, constantes, funciones y otros elementos en un programa. Un identificador es una secuencia de letras y d\u00edgitos, donde el primer s\u00edmbolo debe ser una letra, un guion bajo (<code>_</code>) o el s\u00edmbolo de d\u00f3lar (<code>$</code>). En el pseudoc\u00f3digo se recomienda seguir convenciones de nomenclatura como <code>camelCase</code> para variables y funciones (ej. <code>nombreVariable</code>) y may\u00fasculas con guiones bajos para constantes (ej. <code>MAX_VALUE</code>).</p> <p>Reglas y Convenciones para Identificadores</p> <ul> <li> <p>Reglas Obligatorias:</p> <ul> <li>Comienza con una letra, <code>_</code> o <code>$</code>.</li> <li>No incluye espacios en blanco.</li> <li>No puede ser una palabra reservada ni los literales <code>true</code>, <code>false</code>, <code>null</code>.</li> <li>Es sensible a may\u00fasculas y min\u00fasculas (ej. <code>edad</code> y <code>Edad</code> son distintos).</li> <li>Puede tener cualquier longitud.</li> </ul> </li> <li> <p>Convenciones Recomendadas (pseudoc\u00f3digo):</p> <ul> <li>Variables: <code>camelCase</code> (ej. <code>cantidadAlumnos</code>, <code>longitudPiscina</code>).</li> <li>Constantes: <code>MAYUSCULAS_CON_GUIONES_BAJOS</code> (ej. <code>MAXIMO_PLANTAS</code>, <code>PI</code>).</li> <li>Nombres de Funciones/M\u00e9todos: <code>camelCase</code> (ej. <code>calculaArea()</code>, <code>obtenerDato()</code>).</li> <li>Evitar <code>$</code> o <code>_</code> al principio para identificadores de usuario.</li> </ul> </li> </ul> </li> <li> <p>Palabras Reservadas: Son secuencias de caracteres cuyo uso est\u00e1 reservado por el lenguaje y no pueden utilizarse para crear identificadores. Ejemplos de palabras reservadas pueden incluir <code>const</code>, <code>var</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>true</code>, <code>false</code>, <code>int</code>, <code>decimal</code>, <code>string</code>, <code>bool</code>, <code>Funcion</code>, <code>Main</code>, <code>enum</code>, <code>writeLine</code>, <code>readLine</code>, etc..</p> <p>Palabras Reservadas y Literales Especiales</p> Categor\u00eda Palabras / Literales Descripci\u00f3n Tipos de datos <code>int</code>, <code>decimal</code>, <code>string</code>, <code>bool</code> Tipos de datos primitivos. Modificadores <code>const</code>, <code>var</code>, <code>readonly</code> Para constantes, inferencia de tipos, variables de solo lectura. Control de flujo <code>if</code>, <code>else</code>, <code>switch</code>, <code>for</code>, <code>while</code>, <code>do</code> Estructuras para la l\u00f3gica del programa. Funciones <code>Funcion</code>, <code>Main</code>, <code>writeLine</code>, <code>readLine</code> Para definir funciones, el punto de entrada, salida y entrada. Literales <code>true</code>, <code>false</code>, <code>null</code> Valores booleanos y valor nulo. Enumeraciones <code>enum</code> Para definir tipos enumerados. </li> </ul>"},{"location":"temas/01/index.html#332-variables-concepto-declaracion-e-inicializacion-inferencia-de-tipos-var","title":"3.3.2. Variables: Concepto, Declaraci\u00f3n e Inicializaci\u00f3n, Inferencia de Tipos (<code>var</code>)","text":"<p>Una variable es un contenedor cuyo valor puede cambiar a lo largo de la ejecuci\u00f3n de un programa. *   Concepto: Representan valores en el programa y tienen atributos como nombre (identificador), tipo, valor y mutabilidad. *   Declaraci\u00f3n e Inicializaci\u00f3n: Antes de usar una variable, debe ser declarada, indicando su identificador y su tipo de dato. Opcionalmente, se puede inicializar asign\u00e1ndole un valor inicial en el momento de la declaraci\u00f3n o posteriormente.</p> <p></p><pre><code>Main() {\n  int cantidadLargos = 10;           // Declaraci\u00f3n e inicializaci\u00f3n\n  decimal longitudPiscina;            // Declarada pero no inicializada\n  string nombre = \"Juan\";            // Declaraci\u00f3n e inicializaci\u00f3n\n  bool encontrado = false;           // Declaraci\u00f3n e inicializaci\u00f3n\n  int edad;                          // Declaraci\u00f3n\n  edad = 30;                         // Inicializaci\u00f3n posterior\n}\n</code></pre> *   Inferencia de Tipos (<code>var</code>): El pseudoc\u00f3digo permite usar la palabra clave <code>var</code> para que el sistema infiera el tipo de la variable a partir del valor que se le asigna. Cuando se usa <code>var</code>, la variable siempre debe ser inicializada al declararse.<p></p> <pre><code>Main() {\n  var edad = 30;         // El sistema infiere que es de tipo int\n  var precio = 99.99;    // El sistema infiere que es de tipo decimal\n  var mensaje = \"Hola\";  // El sistema infiere que es de tipo string\n}\n</code></pre>"},{"location":"temas/01/index.html#333-constantes-const-y-variables-de-solo-lectura-readonly","title":"3.3.3. Constantes (<code>const</code>) y Variables de solo lectura (<code>readonly</code>)","text":"<ul> <li>Constantes (<code>const</code>): Son valores fijos que no pueden cambiar su contenido a lo largo de la ejecuci\u00f3n del programa. Deben ser inicializadas al declararse. Se utilizan para facilitar la modificabilidad de programas y dar nombre a valores concretos. Se conocen como constantes literales (tiempo de compilaci\u00f3n).</li> </ul> <pre><code>Main() {\n  const int MAXIMO_NUMERO_PLANTAS = 12;\n  const decimal PI = 3.1415926536;\n\n  writeLine(\"El n\u00famero m\u00e1ximo de plantas es: \" + MAXIMO_NUMERO_PLANTAS);\n  writeLine(\"El valor de PI es: \" + PI);\n}\n</code></pre> <ul> <li>Variables de solo lectura (<code>readonly</code>): Se inicializan una sola vez y su valor no puede ser modificado despu\u00e9s. A diferencia de <code>const</code>, el valor puede ser asignado en tiempo de ejecuci\u00f3n.</li> </ul>"},{"location":"temas/01/index.html#334-literales-concepto-y-ejemplos-booleanos-enteros-caracteres-cadenas","title":"3.3.4. Literales: Concepto y ejemplos (booleanos, enteros, caracteres, cadenas)","text":"<p>Un literal, valor literal o constante literal es un valor concreto que se escribe directamente en el c\u00f3digo.</p> <ul> <li>Literales booleanos: Son <code>true</code> y <code>false</code>.</li> <li>Literales num\u00e9ricos: Son los n\u00fameros que se escriben directamente, como <code>12</code> (entero), <code>3.14</code> (real). Se pueden usar <code>_</code> para mejorar la legibilidad.</li> <li>Literales de cadenas: Una secuencia de caracteres encerrada entre comillas dobles, como <code>\"Hola Mundo\"</code>.</li> </ul> <pre><code>Main() {\n  // Literales booleanos\n  bool estaActivo = true;\n  bool tienePermiso = false;\n\n  // Literales num\u00e9ricos (enteros y reales)\n  int numeroEntero = 123;\n  decimal numeroReal = 45.67;\n  decimal numeroCientifico = 1.23E+5; // 123000.0\n\n  // Literales de cadena\n  string saludo = \"Hola, \";\n  string nombre = \"Mundo\";\n  string fraseCompleta = saludo + nombre + \"!\";\n\n  writeLine(\"Activo: \" + estaActivo);\n  writeLine(\"Permiso: \" + tienePermiso);\n  writeLine(\"Entero: \" + numeroEntero);\n  writeLine(\"Real: \" + numeroReal);\n  writeLine(\"Cient\u00edfico: \" + numeroCientifico);\n  writeLine(\"Frase: \" + fraseCompleta);\n}\n</code></pre>"},{"location":"temas/01/index.html#34-conversiones-de-tipo","title":"3.4. Conversiones de Tipo","text":"<p>Las conversiones de tipo son procesos que permiten cambiar un valor de un tipo de dato a otro.</p> <ul> <li> <p>Conversiones Impl\u00edcitas (Autom\u00e1ticas): Ocurren autom\u00e1ticamente cuando se asigna un valor de un tipo num\u00e9rico a una variable de otro tipo num\u00e9rico que puede contenerlo sin p\u00e9rdida de datos. Por ejemplo, asignar un <code>int</code> a un <code>decimal</code>. En operaciones aritm\u00e9ticas con valores de distinto tipo, el valor m\u00e1s peque\u00f1o se \"promociona\" al tipo m\u00e1s grande.</p> <pre><code>Main() {\n    int entero = 10;\n    decimal real;\n\n    real = entero; // Conversi\u00f3n impl\u00edcita: int (4 bytes) a decimal (8 bytes)\n\n    writeLine(\"Entero: \" + entero);   // Salida: Entero: 10\n    writeLine(\"Real (impl\u00edcito): \" + real); // Salida: Real (impl\u00edcito): 10.0\n}\n</code></pre> </li> <li> <p>Conversiones Expl\u00edcitas (Casting): Se deben indicar de forma manual cuando hay una posible p\u00e9rdida de datos (ej. de un tipo con m\u00e1s bits a uno con menos bits). Esto se hace colocando el tipo de dato deseado entre par\u00e9ntesis delante del valor o expresi\u00f3n a convertir. Hay que tener cuidado con el casting, ya que puede suponer p\u00e9rdida de precisi\u00f3n.</p> <p></p><pre><code>Main() {\n    decimal real = 15.75M;\n    int entero;\n\n    entero = (int)real; // Conversi\u00f3n expl\u00edcita (casting): decimal (8 bytes) a int (4 bytes).\n                        // Se pierde la parte decimal (.75)\n\n    writeLine(\"Real: \" + real);           // Salida: Real: 15.75\n    writeLine(\"Entero (expl\u00edcito): \" + entero); // Salida: Entero (expl\u00edcito): 15\n}\n</code></pre> Tambi\u00e9n para convertir entradas de <code>string</code> a <code>int</code> o <code>decimal</code>: <pre><code>Main() {\n    writeLine(\"Introduce un n\u00famero entero:\");\n    string entradaTexto = ReadLine();\n    int numero = (int)entradaTexto; // Conversi\u00f3n expl\u00edcita de string a int (asumiendo valor v\u00e1lido)\n    writeLine(\"N\u00famero introducido: \" + numero);\n}\n</code></pre><p></p> </li> </ul> <p>Conversiones de Tipos Primitivos (Pseudoc\u00f3digo)</p> Tipo Destino <code>bool</code> <code>int</code> <code>decimal</code> <code>string</code> <code>bool</code> - C C C <code>int</code> N - C C <code>decimal</code> N CI - C <code>string</code> CI CI CI - <ul> <li>CI: Conversi\u00f3n Impl\u00edcita (autom\u00e1tica).</li> <li>C: Conversi\u00f3n Expl\u00edcita (Casting).</li> <li>N: No es posible la conversi\u00f3n directa (o no tiene sentido).<ul> <li>Nota: La conversi\u00f3n a/desde <code>string</code> generalmente implica funciones espec\u00edficas para analizar (<code>Parse</code>) o formatear (<code>ToString</code>) que se realizar\u00edan con casting si el lenguaje lo permite de forma concisa.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#35-operadores-y-expresiones","title":"3.5. Operadores y Expresiones","text":""},{"location":"temas/01/index.html#351-concepto-de-operador-y-expresion","title":"3.5.1. Concepto de Operador y Expresi\u00f3n","text":"<ul> <li>Un operador es un s\u00edmbolo que lleva a cabo operaciones sobre uno o m\u00e1s datos u operandos. Los operadores pueden ser unarios (un operando), binarios (dos operandos) o ternarios (tres operandos). Act\u00faan sobre los tipos de datos y devuelven un resultado de un tipo determinado.</li> <li>Una expresi\u00f3n es una combinaci\u00f3n de operadores y operandos que se eval\u00faa produciendo un \u00fanico resultado de un tipo determinado. Las expresiones pueden ser parte de otras expresiones o sentencias.</li> </ul>"},{"location":"temas/01/index.html#352-tipos-de-operadores","title":"3.5.2. Tipos de Operadores","text":"<ul> <li>Aritm\u00e9ticos: Se utilizan para realizar operaciones matem\u00e1ticas.<ul> <li>Suma (<code>+</code>), Resta (<code>-</code>), Multiplicaci\u00f3n (<code>*</code>), Divisi\u00f3n (<code>/</code>), M\u00f3dulo (<code>%</code>, que devuelve el resto de una divisi\u00f3n).</li> </ul> </li> </ul> <pre><code>Main() {\n  int a = 10, b = 3;\n  int suma = a + b;     // 13\n  int resta = a - b;    // 7\n  int mult = a * b;     // 30\n  decimal div = (decimal)a / b; // 3.333... (con casting para divisi\u00f3n real)\n  int modulo = a % b;   // 1 (resto de 10/3)\n\n  writeLine(\"Suma: \" + suma);\n  writeLine(\"Resta: \" + resta);\n  writeLine(\"Multiplicaci\u00f3n: \" + mult);\n  writeLine(\"Divisi\u00f3n: \" + div);\n  writeLine(\"M\u00f3dulo: \" + modulo);\n}\n</code></pre> <ul> <li>Relacionales (o de Comparaci\u00f3n): Comparan dos operandos y devuelven un valor booleano (<code>true</code> o <code>false</code>).<ul> <li>Igual a (<code>==</code>), Diferente de (<code>!=</code>), Mayor que (<code>&gt;</code>), Menor que (<code>&lt;</code>), Mayor o igual que (<code>&gt;=</code>), Menor o igual que (<code>&lt;=</code>).</li> </ul> </li> </ul> <pre><code>Main() {\n  int x = 5, y = 10;\n  bool igual = (x == y);      // false\n  bool diferente = (x != y);  // true\n  bool mayor = (x &gt; y);       // false\n  bool menor = (x &lt; y);       // true\n  bool mayorIgual = (x &gt;= 5); // true\n  bool menorIgual = (y &lt;= 10);// true\n\n  writeLine(\"X igual a Y: \" + igual);\n  writeLine(\"X diferente de Y: \" + diferente);\n  // ...\n}\n</code></pre> <ul> <li> <p>L\u00f3gicos: Realizan operaciones sobre valores booleanos o resultados de expresiones relacionales, devolviendo un valor booleano.</p> <ul> <li>AND (<code>&amp;&amp;</code>): Verdadero si ambas condiciones son verdaderas.</li> <li>OR (<code>||</code>): Verdadero si al menos una condici\u00f3n es verdadera.</li> <li>NOT (<code>!</code>): Invierte el resultado de una condici\u00f3n.</li> </ul> Operadores L\u00f3gicos y Tablas de Verdad A B <code>NOT A</code> <code>A AND B</code> <code>A OR B</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <pre><code>Main() {\nbool condicion1 = (10 &gt; 5);   // true\nbool condicion2 = (3 == 4);   // false\n\nbool resultadoAND = condicion1 &amp;&amp; condicion2; // false\nbool resultadoOR = condicion1 || condicion2;  // true\nbool resultadoNOT = !condicion1;              // false\n\nwriteLine(\"AND: \" + resultadoAND);\nwriteLine(\"OR: \" + resultadoOR);\nwriteLine(\"NOT: \" + resultadoNOT);\n}\n</code></pre> </li> <li> <p>De Asignaci\u00f3n: Se utilizan para asignar un valor a una variable.</p> <ul> <li>Asignaci\u00f3n simple (<code>=</code>).</li> <li>Asignaciones compuestas (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, que realizan la operaci\u00f3n y luego asignan el resultado).</li> </ul> <pre><code>Main() {\nint numero = 5;\nnumero += 3; // Equivalente a numero = numero + 3; (numero ahora es 8)\nnumero *= 2; // Equivalente a numero = numero * 2; (numero ahora es 16)\n\nwriteLine(\"Numero: \" + numero); // Salida: Numero: 16\n}\n</code></pre> </li> <li> <p>Operador Alfanum\u00e9rico (Concatenaci\u00f3n <code>+</code>): Se utiliza para concatenar (unir) datos de tipo cadena. Tambi\u00e9n puede usarse para combinar cadenas con otros tipos de datos, convirtiendo estos \u00faltimos a cadena autom\u00e1ticamente.</p> <pre><code>Main() {\nstring saludo = \"Hola\";\nstring nombre = \"Ana\";\nstring mensaje = saludo + \", \" + nombre + \"!\"; // Concatenaci\u00f3n\n\nint edad = 25;\nstring info = \"Tu edad es: \" + edad; // Concatena string con int\n\nwriteLine(mensaje); // Salida: Hola, Ana!\nwriteLine(info);    // Salida: Tu edad es: 25\n}\n</code></pre> </li> <li> <p>Especiales:</p> <ul> <li> <p>Ternario (<code>? :</code>): Eval\u00faa una condici\u00f3n y devuelve un resultado u otro en funci\u00f3n de si es verdadera o falsa. Es el \u00fanico operador ternario.</p> <ul> <li>Sintaxis: <code>condicion ? valorSiVerdadero : valorSiFalso;</code>.</li> </ul> <pre><code>Main() {\n    int x = 10, y = 5;\n    string resultado = (x &gt; y) ? \"X es mayor\" : \"Y es mayor o igual\";\n    writeLine(resultado); // Salida: X es mayor\n\n    int maximo = (x &gt; y) ? x : y;\n    writeLine(\"El m\u00e1ximo es: \" + maximo); // Salida: El m\u00e1ximo es: 10\n}\n</code></pre> </li> </ul> </li> <li> <p>Operador de Nulidad (<code>??</code>): Devuelve el valor del operando de la izquierda si no es nulo; de lo contrario, devuelve el de la derecha. \u00datil para proporcionar un valor predeterminado.</p> <pre><code>Main() {\n    string? nombreUsuario = null;\n    string nombreAMostrar = nombreUsuario ?? \"Invitado\"; // Si nombreUsuario es null, usa \"Invitado\"\n    writeLine(\"Bienvenido, \" + nombreAMostrar); // Salida: Bienvenido, Invitado\n\n    nombreUsuario = \"Mar\u00eda\";\n    nombreAMostrar = nombreUsuario ?? \"Invitado\";\n    writeLine(\"Bienvenido, \" + nombreAMostrar); // Salida: Bienvenido, Mar\u00eda\n}\n</code></pre> </li> </ul> Avanzado: Leyes de De Morgan <p>Las Leyes de De Morgan son reglas que te permiten simplificar expresiones l\u00f3gicas y son muy \u00fatiles al trabajar con condiciones en programaci\u00f3n. B\u00e1sicamente, te dicen c\u00f3mo la negaci\u00f3n de una expresi\u00f3n compleja puede ser \"distribuida\" entre sus componentes.</p> Primera Ley de De MorganSegunda Ley de De Morgan <p>La negaci\u00f3n de una conjunci\u00f3n (<code>AND</code>) es equivalente a la disyunci\u00f3n (<code>OR</code>) de las negaciones de sus componentes. En otras palabras, \"no A y B\" es lo mismo que \"no A o no B\".</p> <ul> <li>Expresi\u00f3n original: <code>!(A &amp;&amp; B)</code></li> <li>Equivalente: <code>!A || !B</code></li> </ul> A B <code>A AND B</code> <code>NOT (A AND B)</code> <code>NOT A</code> <code>NOT B</code> <code>NOT A OR NOT B</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>true</code> <p>La negaci\u00f3n de una disyunci\u00f3n (<code>OR</code>) es equivalente a la conjunci\u00f3n (<code>AND</code>) de las negaciones de sus componentes. Dicho de otro modo, \"no A o B\" es lo mismo que \"no A y no B\".</p> <ul> <li>Expresi\u00f3n original: <code>!(A || B)</code></li> <li>Equivalente: <code>!A &amp;&amp; !B</code></li> </ul> A B <code>A OR B</code> <code>NOT (A OR B)</code> <code>NOT A</code> <code>NOT B</code> <code>NOT A AND NOT B</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>true</code>"},{"location":"temas/01/index.html#353-precedencia-de-operadores-y-asociatividad","title":"3.5.3. Precedencia de Operadores y Asociatividad","text":"<ul> <li>Precedencia: Es la prioridad de los operadores, que determina el orden en que se eval\u00faan en una expresi\u00f3n. Por ejemplo, la multiplicaci\u00f3n y divisi\u00f3n tienen mayor precedencia que la suma y resta.</li> <li>Asociatividad: Indica qu\u00e9 operador se eval\u00faa primero en caso de que varios operadores tengan la misma precedencia. Generalmente, la mayor\u00eda son asociativos por la izquierda (se eval\u00faan de izquierda a derecha), mientras que los de asignaci\u00f3n y el condicional son asociativos por la derecha. El uso de par\u00e9ntesis <code>()</code> puede modificar el orden de evaluaci\u00f3n, forzando una precedencia espec\u00edfica y mejorando la legibilidad.</li> </ul> <p>Precedencia de Operadores (Pseudoc\u00f3digo DAW)</p> Operador Tipo Asociatividad <code>( )</code> Agrupaci\u00f3n - <code>!</code> L\u00f3gico Unario Derecha <code>* / %</code> Aritm\u00e9ticos Izquierda <code>+ -</code> Aritm\u00e9ticos Izquierda <code>&lt; &lt;= &gt; &gt;=</code> Relacionales Izquierda <code>== !=</code> Relacionales Izquierda <code>&amp;&amp;</code> L\u00f3gico AND Izquierda <code>|                      |</code> L\u00f3gico OR Izquierda <code>? :</code> Condicional Ternario Derecha <code>= += -= *= /= %= ??</code> Asignaci\u00f3n y Nulidad Derecha"},{"location":"temas/01/index.html#36-comentarios-y-documentacion-basica-del-codigo","title":"3.6. Comentarios y Documentaci\u00f3n B\u00e1sica del C\u00f3digo","text":"<p>Importancia y tipos de Comentarios (una l\u00ednea <code>//</code>, m\u00faltiples l\u00edneas <code>/* */</code>) Los comentarios son notas que los programadores dejan en el c\u00f3digo para explicar su funcionamiento, describir el programa, o cualquier otra indicaci\u00f3n \u00fatil. El programa ignora los comentarios durante su ejecuci\u00f3n. Son esenciales para la legibilidad, el desarrollo y el mantenimiento colaborativo.</p> <p>Los tipos de comentarios comunes en el pseudoc\u00f3digo DAW son:</p> <ul> <li> <p>Comentarios de una sola l\u00ednea (<code>//</code>): Se inician con dos barras y afectan el texto hasta el final de esa l\u00ednea.</p> <p></p><pre><code>// Esto es un comentario de una sola l\u00ednea\n</code></pre> *   Comentarios de m\u00faltiples l\u00edneas (<code>/* */</code>): Se inician con <code>/*</code> y finalizan con <code>*/</code>, abarcando varias l\u00edneas.<p></p> <pre><code>/*\nEsto es un comentario\nque ocupa\nvarias l\u00edneas.\n*/\n</code></pre> </li> </ul> <p>Documentaci\u00f3n Interna del C\u00f3digo</p> <p>La documentaci\u00f3n interna se refiere a los comentarios, encabezados, descripciones y declaraciones del problema que se incluyen directamente dentro del c\u00f3digo fuente. Una buena pr\u00e1ctica es que cada programa comience con comentarios que indiquen, al menos, una breve descripci\u00f3n del programa, el autor y la \u00faltima fecha de modificaci\u00f3n. Adem\u00e1s, en el pseudoc\u00f3digo, como en lenguajes como Java con Javadoc, podr\u00edan emplearse comentarios especiales (<code>/** */</code>) para generar documentaci\u00f3n autom\u00e1tica del programa a partir del c\u00f3digo fuente.</p> <pre><code>/**\n * Nombre del Programa: CalculadoraSimple\n * Autor: [Tu Nombre]\n * Fecha de \u00daltima Modificaci\u00f3n: 2024-10-27\n * Descripci\u00f3n: Este programa realiza operaciones aritm\u00e9ticas b\u00e1sicas\n *              solicitando dos n\u00fameros al usuario.\n */\nMain() {\n  // Declaraci\u00f3n de variables\n  int num1; // Primer n\u00famero introducido por el usuario\n  int num2; // Segundo n\u00famero introducido por el usuario\n  int resultadoSuma; /* Variable para almacenar\n                          el resultado de la suma */\n\n  // El resto del c\u00f3digo del programa ir\u00eda aqu\u00ed\n}\n</code></pre>"},{"location":"temas/01/index.html#4-el-lenguaje-de-programacion-pseudocodigo-daw","title":"4. El Lenguaje de Programaci\u00f3n Pseudoc\u00f3digo DAW","text":"<p>El pseudoc\u00f3digo DAW es un lenguaje de programaci\u00f3n dise\u00f1ado para ser sencillo y f\u00e1cil de entender, ideal para principiantes en programaci\u00f3n. Combina elementos de varios lenguajes de programaci\u00f3n populares, como C#, Java y Python, para ofrecer una sintaxis clara y concisa.</p> <p>Se usar\u00e1 para aprender los conceptos fundamentales de la programaci\u00f3n antes de pasar a lenguajes m\u00e1s complejos y con ello facilitar la transici\u00f3n a lenguajes de programaci\u00f3n reales. Con \u00e9l se pueden crear programas estructurados y modulares y resolver problemas de programaci\u00f3n comunes.</p> <p>Esta gu\u00eda proporciona una visi\u00f3n general de los conceptos b\u00e1sicos del lenguaje DAW, dise\u00f1ado para ser sencillo y f\u00e1cil de aprender. Este lenguaje es ideal para principiantes en programaci\u00f3n, ya que combina elementos de lenguajes populares como C#, Java, Kotlin y JavaScript, adaptados a un entorno educativo.</p> <p>Se usar\u00e1 como base para aprender los fundamentos de la programaci\u00f3n estructurada y modular y servir\u00e1 como base para aprender otros lenguajes m\u00e1s complejos en el futuro.</p> <p>A continuaci\u00f3n, se describen los elementos fundamentales que componen este lenguaje.</p>"},{"location":"temas/01/index.html#a-comentarios","title":"A. Comentarios","text":"<p>Los comentarios son notas que el programa ignora. Sirven para explicar el c\u00f3digo a otros desarrolladores o a ti mismo.</p> <ul> <li>Comentario de una l\u00ednea: Se inicia con dos barras (<code>//</code>).     <pre><code>// Esto es un comentario de una sola l\u00ednea.\nint edad = 30; // Tambi\u00e9n se puede poner al final de una l\u00ednea de c\u00f3digo.\n</code></pre></li> <li>Comentario de varias l\u00edneas: Se inicia con <code>/*</code> y finaliza con <code>*/</code>.     <pre><code>/*\nEste es un comentario\nque se extiende\npor varias l\u00edneas.\n*/\n</code></pre></li> </ul>"},{"location":"temas/01/index.html#b-estructura-del-programa","title":"B. Estructura del Programa","text":"<p>El punto de entrada ser\u00e1 un bloque principal llamado <code>Main()</code>, donde se escribir\u00e1 todo el c\u00f3digo que se ejecutar\u00e1 al iniciar el programa.  Este bloque es obligatorio en todos los programas. Todo programa debe tener este bloque principal, que contiene las instrucciones que se ejecutan al iniciar el programa. Es decir, la l\u00f3gica del programa y/o algoritmo se escribe dentro de este bloque.</p> <pre><code>Main() {\n    // Aqu\u00ed va el c\u00f3digo de nuestro programa.\n    // Es el primer c\u00f3digo que se ejecuta.\n}\n</code></pre>"},{"location":"temas/01/index.html#c-variables-constantes-y-literales","title":"C. Variables, Constantes y Literales","text":"<p>Seguiremos la convenci\u00f3n de nomenclatura <code>camelCase</code> (<code>ejemploVariable</code>, <code>nombreUsuario</code>).</p> <ul> <li>Variables: Son contenedores cuyo valor puede cambiar. Se declaran con un tipo de dato y un nombre.     <pre><code>int edad;\nint contador = 0;\nstring nombre = \"Ana\";\n</code></pre></li> <li>Inferencia de Tipos con <code>var</code>: Con <code>var</code>, el sistema infiere el tipo de la variable a partir del valor que se le asigna. Esto hace que el c\u00f3digo sea m\u00e1s corto y legible. La \u00fanica regla es que siempre debes inicializar la variable cuando usas <code>var</code>.     <pre><code>var edad = 30;       // Se infiere que 'edad' es de tipo int.\nvar nombreCompleto = \"Juan P\u00e9rez\";  // Se infiere que es de tipo string.\n</code></pre></li> <li>Variables que almacenan nulos: Para los tipos que normalmente no pueden ser <code>null</code> (como <code>int</code> o <code>bool</code>), se les puede a\u00f1adir el s\u00edmbolo <code>?</code> para permitirles almacenar la ausencia de valor. Los tipos de referencia como <code>string</code> ya pueden ser <code>null</code> por defecto.     <pre><code>int? edadOpcional = null;\nstring apellido = null; // Un string ya puede ser nulo por defecto\n</code></pre></li> <li>Conversiones entre Tipos:<ul> <li>Conversi\u00f3n Impl\u00edcita: Ocurre autom\u00e1ticamente cuando se asigna un valor a una variable de un tipo que puede contenerlo sin p\u00e9rdida de datos.     <pre><code>int numeroInt = 10;\ndecimal numeroDecimal = numeroInt; // Conversi\u00f3n impl\u00edcita de int a decimal.\n</code></pre></li> <li>Conversi\u00f3n Expl\u00edcita (Casting): Se debe indicar de forma manual cuando hay una posible p\u00e9rdida de datos. Se hace colocando el tipo de dato entre par\u00e9ntesis delante del valor.     <pre><code>decimal numeroDecimal = 10.75m;\nint numeroInt = (int)numeroDecimal; // Conversi\u00f3n expl\u00edcita, se pierde el .75\nwriteLine(numeroInt); // Muestra 10\n</code></pre></li> </ul> </li> <li>Constantes: Son valores fijos que no pueden cambiar. Se utiliza la palabra clave <code>const</code> y deben ser inicializados al declararse.     <pre><code>const decimal PI = 3.14159m;\n</code></pre></li> <li>Variables de solo lectura: Se inicializan una sola vez y su valor no puede ser modificado despu\u00e9s. Usamos la palabra clave <code>readonly</code>.     <pre><code>readonly string version = \"1.0\";\n</code></pre></li> <li>Literales: Son valores fijos que se escriben directamente en el c\u00f3digo (n\u00fameros, texto entre comillas, o los valores <code>true</code> y <code>false</code>).</li> </ul>"},{"location":"temas/01/index.html#d-tipos-de-datos-y-control-de-nulos","title":"D. Tipos de Datos y Control de Nulos","text":"<p>Los tipos de datos que m\u00e1s utilizaremos son <code>int</code>, <code>decimal</code>, <code>string</code> y <code>bool</code>.</p> <ul> <li> <p><code>int</code> (Entero): Almacena n\u00fameros enteros sin decimales, positivos y negativos. Se utiliza para contar o en operaciones matem\u00e1ticas sin fracciones.</p> <ul> <li>Valores: de <code>2.147.483.648</code> a <code>2.147.483.647</code> (aprox.).</li> <li>Operaciones: Suma, resta, multiplicaci\u00f3n, divisi\u00f3n, etc.</li> </ul> </li> <li> <p><code>decimal</code> (Decimal): Almacena n\u00fameros con decimales. Se usa para operaciones financieras o cient\u00edficas que requieren alta precisi\u00f3n. A diferencia de <code>decimal</code>, no tiene la \"m\" al final por defecto, pero es una buena pr\u00e1ctica a\u00f1adirla para indicar expl\u00edcitamente que es un literal de tipo decimal.</p> <ul> <li>Valores: Con hasta 28 o 29 d\u00edgitos decimales de precisi\u00f3n.</li> <li>Operaciones: Las mismas que los enteros, pero con manejo de decimales.</li> </ul> </li> <li> <p><code>string</code> (Cadena): Almacena una secuencia de caracteres. Se utiliza para texto, nombres, frases.</p> <ul> <li>Valores: Cualquier texto entre comillas dobles.</li> <li>Operaciones: Concatenaci\u00f3n (<code>+</code>), b\u00fasqueda de subcadenas, etc.</li> </ul> </li> <li> <p><code>bool</code> (Booleano): Almacena un valor l\u00f3gico. Se utiliza para condiciones de verdadero o falso.</p> <ul> <li>Valores: Solo <code>true</code> o <code>false</code>.</li> <li>Operaciones: Operadores l\u00f3gicos (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>).</li> </ul> </li> <li> <p>Los tipos de valor (<code>int</code>, <code>decimal</code>, <code>bool</code>, etc.) no pueden ser <code>null</code> a menos que se use el operador <code>?</code>.</p> </li> <li> <p>Los tipos de referencia (<code>string</code>) pueden ser <code>null</code> por defecto.</p> </li> </ul>"},{"location":"temas/01/index.html#e-enumeraciones-enum","title":"E. Enumeraciones (<code>enum</code>)","text":"<p>Una enumeraci\u00f3n es un tipo de dato que consiste en un conjunto de constantes nombradas. Se utiliza para hacer el c\u00f3digo m\u00e1s legible y menos propenso a errores, ya que en lugar de usar n\u00fameros \"m\u00e1gicos\" (como <code>1</code> o <code>2</code>), se usan nombres con significado.</p> <ul> <li>Sintaxis: <pre><code>enum DiasSemana {\n    Lunes,     // Se le asigna 0 por defecto\n    Martes,    // Se le asigna 1 por defecto\n    Miercoles,\n    Jueves,\n    Viernes,\n    Sabado,\n    Domingo\n}\n</code></pre></li> <li>Ejemplo de uso: <pre><code>Main() {\n    var hoy = DiasSemana.Miercoles;\n\n    if (hoy == DiasSemana.Miercoles) {\n        writeLine(\"Hoy es mitad de semana\");\n    }\n}\n</code></pre></li> </ul>"},{"location":"temas/01/index.html#f-operadores","title":"F. Operadores","text":"<ul> <li> <p>Operadores Matem\u00e1ticos:</p> <ul> <li><code>+</code> : Suma</li> <li><code>-</code> : Resta</li> <li><code>*</code> : Multiplicaci\u00f3n</li> <li><code>/</code> : Divisi\u00f3n</li> <li><code>%</code> : M\u00f3dulo (devuelve el resto de una divisi\u00f3n)</li> </ul> <p></p> </li> <li> <p>Operadores de Asignaci\u00f3n: Sirven para asignar un valor a una variable.</p> <ul> <li><code>=</code> : Asigna el valor (ej: <code>x = 5;</code>)</li> <li><code>+=</code> : Suma y asigna</li> <li><code>-=</code> : Resta y asigna</li> <li><code>*=</code> : Multiplica y asigna</li> <li><code>/=</code> : Divide y asigna</li> </ul> <p></p> </li> <li> <p>Operadores L\u00f3gicos y de Comparaci\u00f3n:</p> <ul> <li><code>==</code> : Es igual a</li> <li><code>!=</code> : Es diferente de</li> <li><code>&gt;</code> : Mayor que</li> <li><code>&lt;</code> : Menor que</li> <li><code>&gt;=</code> : Mayor o igual que</li> <li><code>&lt;=</code> : Menor o igual que</li> <li><code>&amp;&amp;</code> (AND): Verdadero si ambas condiciones son verdaderas.</li> <li><code>||</code> (OR): Verdadero si al menos una condici\u00f3n es verdadera.</li> <li><code>!</code> (NOT): Invierte el resultado de una condici\u00f3n.</li> </ul> <p></p> </li> <li> <p>Operadores Especiales:</p> <ul> <li>Operador Ternario (<code>? :</code>): Es una forma abreviada de escribir una sentencia <code>if-else</code> simple.<ul> <li>Sintaxis: <code>condicion ? valorSiVerdadero : valorSiFalso;</code> <pre><code>var esMayorDeEdad = (edad &gt;= 18) ? \"S\u00ed\" : \"No\";\n</code></pre></li> </ul> </li> <li>Operador de Nulidad (<code>??</code>):<ul> <li><code>??</code> (Null-Coalescing): Devuelve el valor del operando de la izquierda si no es nulo; de lo contrario, devuelve el de la derecha. Es \u00fatil para proporcionar un valor predeterminado.  <pre><code>var nombreCompleto = nombre ?? \"Desconocido\";\n</code></pre></li> </ul> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#g-entrada-y-salida","title":"G. Entrada y Salida","text":"<ul> <li>Salida (<code>writeLine</code>): Muestra texto en la consola.     <pre><code>writeLine(\"Hola, esto es un mensaje.\");\nvar resultado = 10;\nwriteLine(\"El resultado es: \" + resultado);\n</code></pre></li> <li>Entrada (<code>readLine</code> y casting): Lee una cadena de texto desde la consola. Se debe hacer un casting expl\u00edcito para convertirla a otro tipo, asumiendo que el valor es v\u00e1lido.     <pre><code>writeLine(\"Introduce tu edad:\");\n// Se lee una cadena y se convierte a int\nvar edadUsuario = (int)readLine(); \n\nwriteLine(\"Introduce tu peso (en kg):\");\n// Se lee una cadena y se convierte a decimal\nvar pesoUsuario = (decimal)readLine();\n</code></pre></li> </ul>"}]}